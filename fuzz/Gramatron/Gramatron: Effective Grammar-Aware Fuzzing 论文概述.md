# ABSTRACT

具有输入语法意识的模糊测试工具能够利用语法感知的变异探索更深的程序状态。然而，现有的语法感知模糊测试工具在合成复杂错误触发器方面存在效率问题，主要原因包括：

（i）由于语法结构的存在，语法引入了输入生成过程中的采样偏差；

（ii）目前的解析树变异操作仅能执行局部的小规模变化。

为了解决这些问题，Gramatron采用了语法自动机与激进的变异操作相结合，以更快地合成复杂的错误触发器。我们构建了语法自动机来解决采样偏差问题，通过重构语法以实现对输入状态空间的无偏采样。同时，我们重新设计了语法感知的变异操作，使其更为激进，即进行大规模的变化。

相对于传统的基于解析树的语法，Gramatron可以以更高效的方式一致性地生成复杂的错误触发器。通过Gramatron从头生成的输入具有更高的多样性，相对于现有的模糊测试工具，可以实现高达24.2%的更高代码覆盖率。Gramatron使得输入生成速度提高了98%，输入表示的大小减小了24%。我们重新设计的变异操作更加激进，其效率提高了6.4倍，同时执行这些变异的速度提高了68%。我们在三个解释器上进行了评估，共涉及10个已知的缺陷，其中包括三个复杂错误触发器和七个简单错误触发器，并与两个Nautilus变体进行了对比。Gramatron能够可靠且更快地发现所有复杂错误触发器。对于简单错误触发器，Gramatron在七次测试中有四次优于Nautilus。为了展示Gramatron在实际环境中的有效性，我们将其部署在三个流行的解释器上进行了为期10天的模糊测试活动，在此期间发现了10个新的漏洞。

# 1 INTRODUCTION

诸如PHP、JavaScript（JS）或Ruby之类的语言解释器接受按照语法定义的结构输入。这些解释器构成了复杂应用框架的基础，但本身容易受到攻击，自2018年1月至2021年1月间共有98个漏洞报告 [16, 29, 30]。因此，它们是对攻击者具有吸引力的目标。对这些基础构件（即解释器）进行测试对于确保在其上运行的软件的安全性至关重要，比如Web应用程序。

模糊测试是一种有效的软件安全测试方法。然而，当前的模糊测试方法在对解释器进行深入测试方面效果不佳。大多数由无法理解语法的模糊测试工具 [41, 50] 生成的测试输入在解释器解析阶段会被拒绝。解释器会拒绝所有违反语法的输入，而当模糊测试工具不了解所接受的语法时，它们通常会生成语法不正确的输入。例如，常见的变异操作是随机翻转输入位。如果模糊测试工具不了解语法，它可能会翻转输入关键字中的位，从而创建无效的变异体，这些变异体将被解析器拒绝。如果模糊测试工具不了解语法，解释器在语义分析阶段之后的组件将保持未经测试状态。

对语义分析组件进行模糊测试需要生成语法上有效的输入。现有的语法感知模糊测试工具 [15, 19, 43, 46] 使用：（i）上下文无关文法（CFG）生成测试输入，以及（ii）解析树表示输入的语法结构。模糊测试工具使用语法来变异解析树，以生成用于测试的语法上有效的输入——即语法感知的变异。我们观察到当前语法感知模糊测试方法存在两个问题：

+ Biased sampling：使用现有语法的模糊测试工具在输入状态空间中进行偏倚的采样。这种偏倚是由于上下文无关文法（CFG）中的产生规则布局方式导致的，用于生成输入。这种偏倚可能使模糊测试工具难以生成需要将输入状态空间的多个部分链接在一起的复杂漏洞触发器。

+ Small-scale mutations：语法感知的模糊测试工具使用解析树进行输入生成和变异。现有的解析树变异操作符执行局部的小规模变化。如果模糊测试工具在试图发现具有复杂漏洞触发器的漏洞时浪费时间在与触发漏洞无关的语法部分上，它会减慢模糊测试工具的速度。

我们对上述问题提出了两个解决方案：（i）重构语法中的产生规则以消除采样偏差，以及（ii）重新设计变异操作符以执行更大规模的变化。然而，在基于解析树表示的输入上实现这些解决方案会引入性能开销。这种开销来自于模糊测试工具必须为每个生成或变异的输入维护元数据，以形成输入的派生结构。为了消除这种开销并以性能最优的方式实现我们的解决方案，我们将输入语法转换为有限状态自动机（FSA），我们称之为语法自动机。

语法自动机通过重构语法以消除采样偏差。此外，语法自动机允许高效地执行激进变异（可能会更改更多终结符）。激进变异确保模糊测试工具不会陷入对与触发漏洞无关的语法部分的局部搜索。

我们提出了Gramatron，这是我们的一个概念验证，证明了语法自动机是进行语法感知模糊测试的有效解决方案。Gramatron将输入表示为自动机路径，并使用经过重新设计以实现快速且激进变异的语法感知变异操作符。

我们使用性能微基准测试来评估：（i）Gramatron是否以高性能方式解决了采样偏差，以及（ii）重新设计的变异操作符是否高效地执行激进变化。Gramatron生成的输入具有更高的多样性，因为它们相对于现有模糊测试工具可以获得高达24.2%的覆盖率。这表明我们生成的输入涵盖了更丰富的输入语法语义。此外，平均而言，以自动机路径表示的输入尺寸较小，输入生成速度提高了98%。我们重新设计的变异操作符在平均68%的情况下更快，变异更加激进，速度提高了6.4倍。

为了展示在试图发现复杂的漏洞触发器时，使用传统的语法结合小规模变异可能会存在问题，我们将Gramatron与当前最先进的语法感知模糊测试工具Nautilus [2]的两个变种进行了比较（详见图6）。我们将所有系统与一组包含三个复杂的漏洞触发器和七个简单的漏洞触发器的已知漏洞的三个解释器进行了评估。对于这三个复杂的漏洞触发器，Gramatron在所有情况下都优于其中一个变体，并在其中两个情况下优于另一个变体。Gramatron比其中一个变种更快地发现了七个简单的漏洞触发器中的四个，而比另一个变种更快地发现了其中的三个。此外，为了证明其在实际应用中的有效性，我们将Gramatron部署到了三个流行的解释器上进行了为期10天的模糊测试活动。它发现了10个新的漏洞。此外，我们还讨论了一个作为案例研究发现的漏洞，以展示Gramatron如何有效地生成复杂的漏洞触发器。

Gramatron的主要贡献包括：

- 我们利用语法自动机重构语法，可可靠地生成高度多样化的输入，作为合成复杂漏洞触发器的有效方法

- 我们重新设计和优化语法自动机的变异操作符，使它们能够进行激进的变异，以更快地发现具有复杂触发器的漏洞。

- 作为一个概念验证，我们构建并评估了高效的语法感知模糊测试工具Gramatron。

- 在为期10天的模糊测试活动中，Gramatron发现了10个新漏洞，目前已分配了一个CVE编号。

# 2 BACKGROUND

Gramatron将语法转换为自动机，以解决抽样偏差并实现高效的激进变异。本节介绍了自动机生成所需的背景知识。我们还介绍了针对这种新表示的定制变异操作符。

## 2.1 Context-Free Grammars

语言解释器使用上下文无关文法（CFG）定义其所接受的输入格式。形式上，上下文无关文法（CFG）[48] 定义为：CFG = (T，N，R，S)。T 是有限的终结符集合（生成字符串中的字符）。N 是有限的非终结符号集合（用于生成由 N 生成的 T 的模式的占位符）。R 是一组用于将 N 替换为 T 的规则。规则的形式为 A → a，其中 A 总是一个非终结符号。然而，a 可以是来自 N 和 T 的符号的排列。S 是起始非终结符号，从该符号派生出属于文法的所有字符串。

为了消除抽样偏差，Gramatron使用正常形式对语法进行重构，并强制执行某些规则。我们关注两种正常形式，由Gramatron一起使用以从CFG创建语法自动机：Chomsky 正常形式（CNF）[6] 和 Greibach 正常形式（GNF）[14]。

CNF 和 GNF 与 CFG 类似，只是它们对规则（R）施加了一些约束。对于 CNF，每个非终结符可以生成单个终结符或两个非终结符。对于 GNF，每个非终结符可以生成一个终结符，后跟任意数量的非终结符。

## 2.2 Automaton Classes

我们正式定义了Gramatron用于创建语法自动机的不同自动机类别。此外，我们详细说明了创建语法自动机所涉及的理论挑战的必要背景。

Finite State Automatons. Gramatron使用有限状态自动机（FSA）创建语法自动机以执行模糊测试。这使得Gramatron可以创建轻量级的输入表示，从而实现快速和激进的变异。形式上，一个 FSA 被定义为 M = (Q, Σ, δ, q0, F) [40]。这里，Q 是有限状态集合。Σ 是有限终结符集合。δ 定义了自动机状态上所有转换的集合。q0 是自动机中与文法的起始符号对应的起始状态。F 是自动机中的接受状态。从起始状态到最终状态的一组转换描述了属于文法的输入字符串。

Finite State Automatons. Gramatron利用下推自动机（PDA）创建语法自动机。PDA 是 CFG 的一种语言识别器。在Gramatron的上下文中，我们将考虑一种通过空栈接受输入的 1 状态 PDA。形式上，一个 PDA 被定义为 M = (Q, Σ, Γ, δ, q0, Z, F) [20]。这里，Q 是有限状态集合。Σ 是有限终结符集合。Γ 是可以从栈中推入和弹出的符号集合（称为栈符号）。Z 是推到栈中的起始符号。q0 是起始状态，F 是接受自动机状态。δ 是控制自动机行为的过渡函数。它的参数是 δ(q, a, X)，其中 q ∈ Q，a ∈ Σ，X ∈ Γ。δ 的输出是有限状态的一组配对 (p, γ)，其中 p 是一个新的状态，γ 是用于替换栈顶的符号 X 的字符串，它以相反的顺序被推入栈中。如果 γ 为空，则只弹出栈中的 X。

## 2.3 Grammar-Aware Mutation Operators

语法感知的变异操作符在维持语法有效性的同时对输入进行变异。它们接受语法和一个语法上有效的测试用例作为输入，用于创建变异体。有三种已经被证明在发现深层次错误方面非常成功的变异操作符 [2]：随机变异（选择一个随机的非叶子非终结符节点并创建一个新的子树）、随机递归（查找递归产生规则并展开最多n次）以及拼接（将两个输入合并而保持语法结构）。我们在Gramatron中实现了它们，并为了快速且积极地生成变异体进行了定制。

```c
  if (data->mut_idx == 0) { // Perform random mutation
      data->mutated_walk = performRandomMutation(data->afl->pda, data->orig_walk);
      data->mut_alloced = 1;
  } else if (data->mut_idx == 1 && data->recurlen) { // Perform recursive mutation
      data->mutated_walk = doMult(data->orig_walk, data->recurIdx, data->recurlen);  
      data->mut_alloced = 1;
  } else if (data->mut_idx == 2) { // Perform splice mutation

      // Read the input representation for the splice candidate
      u8* automaton_fn = alloc_printf("%s.aut", add_buf);
      Array* spliceCandidate = read_input(data->afl->pda, automaton_fn);

      data->mutated_walk = performSpliceOne(data->orig_walk, data->statemap, spliceCandidate); 
      data->mut_alloced = 1;
      free(spliceCandidate->start);
      free(spliceCandidate);
      free(automaton_fn);
  } else { // Generate an input from scratch
      data->mutated_walk = gen_input(data->afl->pda, NULL); 
      data->mut_alloced = 1;
  }
```

# 3 GRAMATRON OVERVIEW

Gramatron是一个基于覆盖率引导的、语法感知的生成式模糊测试工具。作为输入，Gramatron接受目标所接受的上下文无关文法（CFG）。Gramatron输出导致崩溃的测试用例。图1突显了Gramatron的两个明显阶段：第一是预处理阶段，接着是第二个模糊测试阶段。在预处理阶段，Gramatron将一个文法转换为其对应的文法自动机。它首先将文法转换为一种用于无偏输入采样的形式，然后创建文法自动机。该自动机是一个有限状态自动机（FSA），它编码了由文法表示的输入空间。

![](https://raw.githubusercontent.com/mark0-cn/blog_img/master/img/202308072044320.png)

在模糊测试阶段，Gramatron使用了经过重新设计以实现快速且积极变异的自动机和变异操作符。这使得Gramatron能够迅速发现具有复杂触发条件的漏洞。此外，为了引导模糊测试关注文法的有趣部分，它还使用覆盖率反馈来引导变异过程。

# 4 GRAMMAR AUTOMATONS

为了在应用程序解析器之外进行模糊测试，模糊器必须生成语法上有效的输入。以前的模糊器使用带有上下文无关文法（CFG）的解析树进行输入生成和变异。解析树编码了从文法生成输入所应用的替换规则。模糊器使用这些信息进行变异。由于偏倚的抽样和局部小规模变异，现有的语法感知模糊器在合成复杂漏洞触发器方面效果不佳。

传统的文法结构在随机选择扩展替换规则时，引入了输入生成的偏差。文法规则的布局使得在生成输入状态空间的某些部分方面，概率上更难以生成。这种偏差反过来会导致模糊器较不有效地生成某些模式，从而降低了漏洞发现的速度。现有的模糊器使用为解析树设计的变异操作符，这些操作符执行局部小规模的更改。如果模糊器陷入模糊与触发漏洞无关的文法部分，这些小规模变异就会产生负面影响。

Gramatron对CFG执行自动两步转换以创建文法自动机。首先，它将CFG转换为其Greibach Normal Form（GNF），以执行文法重构。其次，它将文法的GNF转换为一个自动机。Gramatron可以将遵守文法的任何输入编码为自动机路径。文法自动机对文法进行了重构，使模糊器能够从输入状态空间中进行无偏抽样。这使得模糊器更频繁地生成具有更高多样性的输入。我们还重新设计了变异操作符，使其在文法自动机上进行操作并以高效的方式执行积极变异，以发现具有复杂触发条件的漏洞。

## 4.1 Motivating Example

以下简明的示例说明了文法自动机如何从输入分布中进行无偏抽样，并允许高效地执行积极变异。Listing 1呈现了PHP文法的一个子集[37]。

![](https://raw.githubusercontent.com/mark0-cn/blog_img/master/img/202308072059407.png)

Biased sampling. Listing 1中的CFG显示了传统结构如何强制模糊器从输入分布中进行偏向抽样。从这个CFG生成输入的模糊器将从符号（program）开始，迭代地应用规则，直到生成的字符串没有非终结符为止。能够生成两倍多不同子树的callStmt与retStmt相同的概率被选中用于生成。因此，模糊器对应于callStmt的子树进行了欠采样。这导致生成的输入多样性较低，从而在模糊测试期间导致测试覆盖率较低。

![](https://raw.githubusercontent.com/mark0-cn/blog_img/master/img/202308072102919.png)

![](https://raw.githubusercontent.com/mark0-cn/blog_img/master/img/202308072102089.png)

图3所示的文法自动机描述了CFG的GNF（Listing 2）。GNF允许Gramatron从输入状态空间中进行无偏抽样。它重新结构了文法，明确枚举了每个非终结符可以生成的所有不同子树。因此，我们可以看到与函数调用对应的子树变得生成的可能性增加了一倍，因为它们可以生成两倍多的子树。

Aggressive mutations. Gramatron使用积极变异操作符。具体来说，给定一个输入字符串和一个变异点，Gramatron会相对于变异点一直变异到字符串的末尾。与解析树相比，自动机的设计更有利于执行这种变化。

## 4.2 Automaton Construction

我们首先描述了 Gramatron 使用的自动机构造算法。然后，我们将讨论在应用此算法时面临的挑战，以及我们用来解决该挑战的见解。

Construction Algorithm. Gramatron 通过两个步骤来将语法转换为相应的自动机：（i）将语法转换为其 GNF（格雷巴赫正规形式），（ii）将转换后的语法转换为自动机。首先，Gramatron 将语法 G 转换为其 CNF（乔姆斯基正规形式），然后对其 CNF 进行固定点迭代，将其转换为其 GNF。Gramatron 首先通过为每个 CFG 产生规则指定 PDA 的转移函数来执行其语法构造。对于 GNF 中的语法，转移函数为：δ(q, t, A) = {(q, W)|A → tW ∈ R}。其中，t 是终端，A 是非终端，W 对应于一个非终端集合。Gramatron 使用这个转移函数来构建语法自动机。它通过枚举（如果可能）属于 CFG 的所有有效 PDA 堆栈状态来实现。语法自动机中的最终状态对应于空栈。对于每个堆栈状态，语法自动机中都存在一个状态。

Gramatron使用基于工作列表的算法来构建自动机。它使用一个元组来初始化工作列表，该元组由初始自动机状态和其带有语法开始符号的解析堆栈组成。它在工作列表为空之前进行迭代。在每次迭代中，它执行以下步骤：（i）从工作列表中弹出一个元素，（ii）从元素的解析堆栈（P）中弹出顶部的堆栈符号（S）以创建新的堆栈P'。对于堆栈符号，根据转移函数找到所有可能的转换，（iii）对于每个转换，通过将堆栈符号（如果有的话）以相反的顺序推入堆栈P'来计算新的堆栈P''，（iv-a）如果P''等于先前生成的自动机状态的解析堆栈，则使用终端t从当前状态创建到该状态的转换，并且（iv-b）如果P''是一个新的堆栈状态，则使用终端t从当前状态创建到一个具有堆栈P''的新自动机状态，并将新的自动机状态以及其解析堆栈添加到工作列表中。在有限状态自动机上进行自动机行走将创建一个新的种子输入。

Construction Challenge/Insight. 从理论上讲，将任意的上下文无关文法（CFG）转化为有限状态自动机（FSA）是不可能的。这种不可能性源于一种特定类型的文法，即具有无限自动机状态的自嵌套文法。如果一个CFG包含形式为 ω ∗=⇒uωv 的产生式规则，则称其为自嵌套。这里 {u, v} ∈ T + 且 ω ∈ N，如ğ 2.1所示。

然而，我们得出的一个关键洞察是，语法感知模糊器对生成的输入大小有一个上界。这确保它们不会生成任意大的输入。因此，它们实例化了CFG指定的语言的一个子集（下估计）。这里，语言指的是可以从CFG生成的输入的（可能）无限状态空间。Gramatron利用这个洞察来在创建语法自动机时解决了理论上的不可能性。它使用正则语言近似[8, 25, 33]来近似CFG。然后将这个正则近似转化为语法自动机。

为了进行这种正则近似，Gramatron在生成自动机时限制了解析堆栈的大小（在算法中表示为P）为一个上界[4, 22]。因此，构建算法终止并构建了一个自动机。产生的折衷是生成的自动机只能表示自嵌套文法指定的语言的一个子集。在编程语言文法的背景下，这意味着自嵌套规则的结构只能嵌套到一个静态深度。这个深度与用户指定的允许堆栈大小成正比，可以相应地进行调整。

然而，在模糊测试的背景下，这种权衡并不会产生负面影响。语法感知模糊器已经限制了输入大小，以防止生成任意大的输入。因此，语法自动机使得Gramatron在与现有的语法感知模糊器相比具有相同的表达能力的同时，性能更高。

上述讨论中的一个例外是非自嵌套文法。它们不包含任何自嵌套规则。这种文法有有限数量的可能状态和转换[1]。因此，Gramatron可以生成一个语法自动机，可以生成与非自嵌套CFG指定的确切语言相同的语言。

## 4.3 Automata-Based Mutation

变异操作符（splicing, random mutation, and random recursive）是在语法自动机行走路径上进行操作的。为了解决陷入局部子树的风险，我们使拼接和随机变异操作符能够执行更加积极的变化。给定一个输入字符串和其中的一个变异点，Gramatron会对其进行变异，直到达到字符串的末尾。对于每个变异操作符，假设输入I被变异。它在行走形式中的相应表示是W = [T1, ..TN ]，由N个转换组成，用于从自动机的起始状态到达其最终接受状态。访问过的自动机状态为S = [S1, ..SN +1]。

+ Splice: 假设有两个表示为自动机行走路径的输入，W1 和 W2。从 W1 中随机选择一个转换作为拼接点，记作 TC，其中 1 ≤ C ≤ N。从该点出发的子路径将被替换为来自 W2 的一个适当的子路径，这个子路径与 TC 相同的起始状态，即 SC。自动机在拼接方面表现优于解析树，因为解析树需要对解析树节点进行繁重的重构。该操作符不仅改变了在所选拼接点下的子树，还改变了子树右侧的所有内容。对于自动机，相同的变异只需要将两个列表连接起来。

+ random mutation: Gramatron执行一个三步过程来执行这种变异。

首先，它在行走路径 W 中选择一个随机转换 TC，以分叉这个路径。

```c
// Get offset at which to generate new input and slice it
int idx = rand() % input->used;
sliced = slice(input, idx);
```

第二，它使用 C - 1 个转换生成输入的未变异部分，保持原样。

第三，在分叉的状态下，Gramatron在自动机上进行随机行走，直到达到最终状态，从而生成变异体。这个操作符在生成以自动机行走路径表示的输入方面变得更快。这是因为它需要从提供的语法中生成变异体的新子字符串。由于语法自动机使得输入生成更快，新变异体的子字符串生成也更快。

+ random recursive: 在没有预处理的情况下，在解析树中查找递归的运行时复杂性为 O(n log n)，其中 n 是树节点的数量。这是因为对于每个节点，您必须递归地遍历其父节点，以找到所有递归特征。Gramatron将查找递归特征的运行时复杂性限制为 O(m)，其中 m 是输入中的终端数量，且 m << n。语法自动机使得 Gramatron 只需遍历一次行走路径 W 就能记录所有递归特征。然后，它将与随机选择的递归特征相对应的子路径复制多达 n 次。在当前的实现中，n = 5。

```c
/*Concats prefix + feature *mult*/
void concatPrefixFeature(Array* prefix, Array* feature) { 
    // XXX: Currently we have hardcoded the multiplication threshold for adding
    // the recursive feature. Might want to fix it to choose a random number upper
    // bounded by a static value instead.
    terminal* featureptr;
    int len = rand() % RECUR_THRESHOLD;
    for (int x = 0; x < len; x++) { 
        for (int y = 0; y < feature->used; y++) {
            featureptr = & feature->start[y];
            insertArray(prefix, featureptr->state, featureptr->symbol, featureptr->symbol_len, featureptr->trigger_idx);
        }
    }
}
```

# 5 IMPLEMENTATION

Gramatron被实现为C和Python混合编程：其（提前编译）语法预处理部分使用Python实现，而（性能关键）输入生成器和变异器部分使用C实现。Gramatron接受一个被模糊测试目标所接受的语法作为输入。Gramatron修改了AFL++ [9]，利用语法自动机在进行模糊测试时执行输入生成和变异操作。此外，Gramatron还利用来自模糊测试目标的代码覆盖反馈来指导其变异操作。

## 5.1 Fuzzing Workflow

Gramatron 是一个基于覆盖率的语法感知模糊器。执行基于覆盖率的模糊测试有三个主要阶段 [23, 47]：(i) 种子调度，从一组种子中选择一个种子用于生成变异体；(ii) 种子变异，从种子生成变异体；(iii) 种子选择，根据反馈选择有趣的种子作为进一步模糊测试的候选。Gramatron 扩展了 AFL++ 的种子变异，使其具备语法感知能力，以生成符合语法的有效输入。为了防止变异体过大，Gramatron 降低了（但没有禁止）达到大于2048字节的输入的优先级。

Gramatron 分为两个阶段：语料生成阶段和模糊测试阶段。在语料生成阶段，Gramatron 通过在语法自动机上执行随机遍历，生成预定义数量的符合语法的种子输入。在当前实现中，Gramatron 生成100个种子输入。使用这个种子语料，Gramatron 转入模糊测试阶段。

每个模糊迭代包括四个步骤：(i) 从队列中选择一个种子；(ii) 将种子通过每个变异操作符进行变异；(iii) 在模糊目标上测试生成的变异体；(iv) 根据覆盖率反馈选择候选项进行进一步测试。此外，为了防止模糊器陷入局部覆盖率最小值，每个模糊迭代还会通过对语法自动机进行随机遍历来生成一个候选项。