# ABSTRACT

具有输入语法意识的模糊测试工具能够利用语法感知的变异探索更深的程序状态。然而，现有的语法感知模糊测试工具在合成复杂错误触发器方面存在效率问题，主要原因包括：

（i）由于语法结构的存在，语法引入了输入生成过程中的采样偏差；

（ii）目前的解析树变异操作仅能执行局部的小规模变化。

为了解决这些问题，Gramatron采用了语法自动机与激进的变异操作相结合，以更快地合成复杂的错误触发器。我们构建了语法自动机来解决采样偏差问题，通过重构语法以实现对输入状态空间的无偏采样。同时，我们重新设计了语法感知的变异操作，使其更为激进，即进行大规模的变化。

相对于传统的基于解析树的语法，Gramatron可以以更高效的方式一致性地生成复杂的错误触发器。通过Gramatron从头生成的输入具有更高的多样性，相对于现有的模糊测试工具，可以实现高达24.2%的更高代码覆盖率。Gramatron使得输入生成速度提高了98%，输入表示的大小减小了24%。我们重新设计的变异操作更加激进，其效率提高了6.4倍，同时执行这些变异的速度提高了68%。我们在三个解释器上进行了评估，共涉及10个已知的缺陷，其中包括三个复杂错误触发器和七个简单错误触发器，并与两个Nautilus变体进行了对比。Gramatron能够可靠且更快地发现所有复杂错误触发器。对于简单错误触发器，Gramatron在七次测试中有四次优于Nautilus。为了展示Gramatron在实际环境中的有效性，我们将其部署在三个流行的解释器上进行了为期10天的模糊测试活动，在此期间发现了10个新的漏洞。

# 1 INTRODUCTION

诸如PHP、JavaScript（JS）或Ruby之类的语言解释器接受按照语法定义的结构输入。这些解释器构成了复杂应用框架的基础，但本身容易受到攻击，自2018年1月至2021年1月间共有98个漏洞报告 [16, 29, 30]。因此，它们是对攻击者具有吸引力的目标。对这些基础构件（即解释器）进行测试对于确保在其上运行的软件的安全性至关重要，比如Web应用程序。

模糊测试是一种有效的软件安全测试方法。然而，当前的模糊测试方法在对解释器进行深入测试方面效果不佳。大多数由无法理解语法的模糊测试工具 [41, 50] 生成的测试输入在解释器解析阶段会被拒绝。解释器会拒绝所有违反语法的输入，而当模糊测试工具不了解所接受的语法时，它们通常会生成语法不正确的输入。例如，常见的变异操作是随机翻转输入位。如果模糊测试工具不了解语法，它可能会翻转输入关键字中的位，从而创建无效的变异体，这些变异体将被解析器拒绝。如果模糊测试工具不了解语法，解释器在语义分析阶段之后的组件将保持未经测试状态。

对语义分析组件进行模糊测试需要生成语法上有效的输入。现有的语法感知模糊测试工具 [15, 19, 43, 46] 使用：（i）上下文无关文法（CFG）生成测试输入，以及（ii）解析树表示输入的语法结构。模糊测试工具使用语法来变异解析树，以生成用于测试的语法上有效的输入——即语法感知的变异。我们观察到当前语法感知模糊测试方法存在两个问题：

+ Biased sampling：使用现有语法的模糊测试工具在输入状态空间中进行偏倚的采样。这种偏倚是由于上下文无关文法（CFG）中的产生规则布局方式导致的，用于生成输入。这种偏倚可能使模糊测试工具难以生成需要将输入状态空间的多个部分链接在一起的复杂漏洞触发器。

+ Small-scale mutations：语法感知的模糊测试工具使用解析树进行输入生成和变异。现有的解析树变异操作符执行局部的小规模变化。如果模糊测试工具在试图发现具有复杂漏洞触发器的漏洞时浪费时间在与触发漏洞无关的语法部分上，它会减慢模糊测试工具的速度。

我们对上述问题提出了两个解决方案：（i）重构语法中的产生规则以消除采样偏差，以及（ii）重新设计变异操作符以执行更大规模的变化。然而，在基于解析树表示的输入上实现这些解决方案会引入性能开销。这种开销来自于模糊测试工具必须为每个生成或变异的输入维护元数据，以形成输入的派生结构。为了消除这种开销并以性能最优的方式实现我们的解决方案，我们将输入语法转换为有限状态自动机（FSA），我们称之为语法自动机。

语法自动机通过重构语法以消除采样偏差。此外，语法自动机允许高效地执行激进变异（可能会更改更多终结符）。激进变异确保模糊测试工具不会陷入对与触发漏洞无关的语法部分的局部搜索。

我们提出了Gramatron，这是我们的一个概念验证，证明了语法自动机是进行语法感知模糊测试的有效解决方案。Gramatron将输入表示为自动机路径，并使用经过重新设计以实现快速且激进变异的语法感知变异操作符。

我们使用性能微基准测试来评估：（i）Gramatron是否以高性能方式解决了采样偏差，以及（ii）重新设计的变异操作符是否高效地执行激进变化。Gramatron生成的输入具有更高的多样性，因为它们相对于现有模糊测试工具可以获得高达24.2%的覆盖率。这表明我们生成的输入涵盖了更丰富的输入语法语义。此外，平均而言，以自动机路径表示的输入尺寸较小，输入生成速度提高了98%。我们重新设计的变异操作符在平均68%的情况下更快，变异更加激进，速度提高了6.4倍。

为了展示在试图发现复杂的漏洞触发器时，使用传统的语法结合小规模变异可能会存在问题，我们将Gramatron与当前最先进的语法感知模糊测试工具Nautilus [2]的两个变种进行了比较（详见图6）。我们将所有系统与一组包含三个复杂的漏洞触发器和七个简单的漏洞触发器的已知漏洞的三个解释器进行了评估。对于这三个复杂的漏洞触发器，Gramatron在所有情况下都优于其中一个变体，并在其中两个情况下优于另一个变体。Gramatron比其中一个变种更快地发现了七个简单的漏洞触发器中的四个，而比另一个变种更快地发现了其中的三个。此外，为了证明其在实际应用中的有效性，我们将Gramatron部署到了三个流行的解释器上进行了为期10天的模糊测试活动。它发现了10个新的漏洞。此外，我们还讨论了一个作为案例研究发现的漏洞，以展示Gramatron如何有效地生成复杂的漏洞触发器。

Gramatron的主要贡献包括：

- 我们利用语法自动机重构语法，可可靠地生成高度多样化的输入，作为合成复杂漏洞触发器的有效方法

- 我们重新设计和优化语法自动机的变异操作符，使它们能够进行激进的变异，以更快地发现具有复杂触发器的漏洞。

- 作为一个概念验证，我们构建并评估了高效的语法感知模糊测试工具Gramatron。

- 在为期10天的模糊测试活动中，Gramatron发现了10个新漏洞，目前已分配了一个CVE编号。

# 2 BACKGROUND

Gramatron将语法转换为自动机，以解决抽样偏差并实现高效的激进变异。本节介绍了自动机生成所需的背景知识。我们还介绍了针对这种新表示的定制变异操作符。

## 2.1 Context-Free Grammars

语言解释器使用上下文无关文法（CFG）定义其所接受的输入格式。形式上，上下文无关文法（CFG）[48] 定义为：CFG = (T，N，R，S)。T 是有限的终结符集合（生成字符串中的字符）。N 是有限的非终结符号集合（用于生成由 N 生成的 T 的模式的占位符）。R 是一组用于将 N 替换为 T 的规则。规则的形式为 A → a，其中 A 总是一个非终结符号。然而，a 可以是来自 N 和 T 的符号的排列。S 是起始非终结符号，从该符号派生出属于文法的所有字符串。

为了消除抽样偏差，Gramatron使用正常形式对语法进行重构，并强制执行某些规则。我们关注两种正常形式，由Gramatron一起使用以从CFG创建语法自动机：Chomsky 正常形式（CNF）[6] 和 Greibach 正常形式（GNF）[14]。

CNF 和 GNF 与 CFG 类似，只是它们对规则（R）施加了一些约束。对于 CNF，每个非终结符可以生成单个终结符或两个非终结符。对于 GNF，每个非终结符可以生成一个终结符，后跟任意数量的非终结符。

## 2.2 Automaton Classes

我们正式定义了Gramatron用于创建语法自动机的不同自动机类别。此外，我们详细说明了创建语法自动机所涉及的理论挑战的必要背景。

Finite State Automatons. Gramatron使用有限状态自动机（FSA）创建语法自动机以执行模糊测试。这使得Gramatron可以创建轻量级的输入表示，从而实现快速和激进的变异。形式上，一个 FSA 被定义为 M = (Q, Σ, δ, q0, F) [40]。这里，Q 是有限状态集合。Σ 是有限终结符集合。δ 定义了自动机状态上所有转换的集合。q0 是自动机中与文法的起始符号对应的起始状态。F 是自动机中的接受状态。从起始状态到最终状态的一组转换描述了属于文法的输入字符串。

Finite State Automatons. Gramatron利用下推自动机（PDA）创建语法自动机。PDA 是 CFG 的一种语言识别器。在Gramatron的上下文中，我们将考虑一种通过空栈接受输入的 1 状态 PDA。形式上，一个 PDA 被定义为 M = (Q, Σ, Γ, δ, q0, Z, F) [20]。这里，Q 是有限状态集合。Σ 是有限终结符集合。Γ 是可以从栈中推入和弹出的符号集合（称为栈符号）。Z 是推到栈中的起始符号。q0 是起始状态，F 是接受自动机状态。δ 是控制自动机行为的过渡函数。它的参数是 δ(q, a, X)，其中 q ∈ Q，a ∈ Σ，X ∈ Γ。δ 的输出是有限状态的一组配对 (p, γ)，其中 p 是一个新的状态，γ 是用于替换栈顶的符号 X 的字符串，它以相反的顺序被推入栈中。如果 γ 为空，则只弹出栈中的 X。

## 2.3 Grammar-Aware Mutation Operators

语法感知的变异操作符在维持语法有效性的同时对输入进行变异。它们接受语法和一个语法上有效的测试用例作为输入，用于创建变异体。有三种已经被证明在发现深层次错误方面非常成功的变异操作符 [2]：随机变异（选择一个随机的非叶子非终结符节点并创建一个新的子树）、随机递归（查找递归产生规则并展开最多n次）以及拼接（将两个输入合并而保持语法结构）。我们在Gramatron中实现了它们，并为了快速且积极地生成变异体进行了定制。

# 3 GRAMATRON OVERVIEW

Gramatron是一个基于覆盖率引导的、语法感知的生成式模糊测试工具。作为输入，Gramatron接受目标所接受的上下文无关文法（CFG）。Gramatron输出导致崩溃的测试用例。图1突显了Gramatron的两个明显阶段：第一是预处理阶段，接着是第二个模糊测试阶段。在预处理阶段，Gramatron将一个文法转换为其对应的文法自动机。它首先将文法转换为一种用于无偏输入采样的形式，然后创建文法自动机。该自动机是一个有限状态自动机（FSA），它编码了由文法表示的输入空间。

![](https://raw.githubusercontent.com/mark0-cn/blog_img/master/img/202308072044320.png)

在模糊测试阶段，Gramatron使用了经过重新设计以实现快速且积极变异的自动机和变异操作符。这使得Gramatron能够迅速发现具有复杂触发条件的漏洞。此外，为了引导模糊测试关注文法的有趣部分，它还使用覆盖率反馈来引导变异过程。

# 4 GRAMMAR AUTOMATONS

为了在应用程序解析器之外进行模糊测试，模糊器必须生成语法上有效的输入。以前的模糊器使用带有上下文无关文法（CFG）的解析树进行输入生成和变异。解析树编码了从文法生成输入所应用的替换规则。模糊器使用这些信息进行变异。由于偏倚的抽样和局部小规模变异，现有的语法感知模糊器在合成复杂漏洞触发器方面效果不佳。

传统的文法结构在随机选择扩展替换规则时，引入了输入生成的偏差。文法规则的布局使得在生成输入状态空间的某些部分方面，概率上更难以生成。这种偏差反过来会导致模糊器较不有效地生成某些模式，从而降低了漏洞发现的速度。现有的模糊器使用为解析树设计的变异操作符，这些操作符执行局部小规模的更改。如果模糊器陷入模糊与触发漏洞无关的文法部分，这些小规模变异就会产生负面影响。

Gramatron对CFG执行自动两步转换以创建文法自动机。首先，它将CFG转换为其Greibach Normal Form（GNF），以执行文法重构。其次，它将文法的GNF转换为一个自动机。Gramatron可以将遵守文法的任何输入编码为自动机路径。文法自动机对文法进行了重构，使模糊器能够从输入状态空间中进行无偏抽样。这使得模糊器更频繁地生成具有更高多样性的输入。我们还重新设计了变异操作符，使其在文法自动机上进行操作并以高效的方式执行积极变异，以发现具有复杂触发条件的漏洞。

## 4.1 Motivating Example

以下简明的示例说明了文法自动机如何从输入分布中进行无偏抽样，并允许高效地执行积极变异。Listing 1呈现了PHP文法的一个子集[37]。

![](https://raw.githubusercontent.com/mark0-cn/blog_img/master/img/202308072059407.png)

Biased sampling. Listing 1中的CFG显示了传统结构如何强制模糊器从输入分布中进行偏向抽样。从这个CFG生成输入的模糊器将从符号（program）开始，迭代地应用规则，直到生成的字符串没有非终结符为止。能够生成两倍多不同子树的callStmt与retStmt相同的概率被选中用于生成。因此，模糊器对应于callStmt的子树进行了欠采样。这导致生成的输入多样性较低，从而在模糊测试期间导致测试覆盖率较低。

![](https://raw.githubusercontent.com/mark0-cn/blog_img/master/img/202308072102919.png)

![](https://raw.githubusercontent.com/mark0-cn/blog_img/master/img/202308072102089.png)

图3所示的文法自动机描述了CFG的GNF（Listing 2）。GNF允许Gramatron从输入状态空间中进行无偏抽样。它重新结构了文法，明确枚举了每个非终结符可以生成的所有不同子树。因此，我们可以看到与函数调用对应的子树变得生成的可能性增加了一倍，因为它们可以生成两倍多的子树。

Aggressive mutations. Gramatron使用积极变异操作符。具体来说，给定一个输入字符串和一个变异点，Gramatron会相对于变异点一直变异到字符串的末尾。与解析树相比，自动机的设计更有利于执行这种变化。
