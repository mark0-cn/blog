# corpus

```rust
pub trait Corpus: UsesInput + Serialize + for<'de> Deserialize<'de> {
    // Required methods
    fn count(&self) -> usize;
    fn add(
        &mut self,
        testcase: Testcase<Self::Input>
    ) -> Result<CorpusId, Error>;
    fn replace(
        &mut self,
        idx: CorpusId,
        testcase: Testcase<Self::Input>
    ) -> Result<Testcase<Self::Input>, Error>;
    fn remove(&mut self, id: CorpusId) -> Result<Testcase<Self::Input>, Error>;
    fn get(
        &self,
        id: CorpusId
    ) -> Result<&RefCell<Testcase<Self::Input>>, Error>;
    fn current(&self) -> &Option<CorpusId>;
    fn current_mut(&mut self) -> &mut Option<CorpusId>;
    fn next(&self, id: CorpusId) -> Option<CorpusId>;
    fn prev(&self, id: CorpusId) -> Option<CorpusId>;
    fn first(&self) -> Option<CorpusId>;
    fn last(&self) -> Option<CorpusId>;
    fn load_input_into(
        &self,
        testcase: &mut Testcase<Self::Input>
    ) -> Result<(), Error>;
    fn store_input_from(
        &self,
        testcase: &Testcase<Self::Input>
    ) -> Result<(), Error>;

    // Provided methods
    fn is_empty(&self) -> bool { ... }
    fn ids(&self) -> CorpusIdIterator<'_, Self> ⓘ { ... }
    fn nth(&self, nth: usize) -> CorpusId { ... }
    fn cloned_input_for_id(&self, idx: CorpusId) -> Result<Self::Input, Error> { ... }
}
```

## 常见的corpus

底层实现顺序：
InMemoryCorpus->InMemoryOnDiskCorpus->CachedOnDiskCorpus->OnDiskCorpus

### CachedOnDiskCorpus

libafl::corpus::cached::CachedOnDiskCorpus

在内存中保持最大数量的测试用例，并在需要时从磁盘加载它们。驱逐策略采用先进先出（FIFO）方式。

```rust
pub struct CachedOnDiskCorpus<I>
where
    I: Input,
{
    inner: InMemoryOnDiskCorpus<I>,
    cached_indexes: RefCell<VecDeque<CorpusId>>,
    cache_max_len: usize,
}
```
底层实现`InMemoryOnDiskCorpus`

### InMemoryCorpus

libafl::corpus::inmemory::InMemoryCorpus

所有handlding 都储存在内存中

```rust
pub struct InMemoryCorpus<I>
where
    I: Input,
{
    /*
    storage:用于储存测试用例
    current:当前测试用例的id
    */
    storage: TestcaseStorage<I>,
    current: Option<CorpusId>,
}

pub struct TestcaseStorage<I>
where
    I: Input,
{
    /*
    map: TestcaseStorageMap<I>
    The map in which testcases are stored

    keys: Vec<CorpusId>
    The keys in order (use Vec::binary_search)
    */
    pub map: TestcaseStorageMap<I>,
    pub keys: Vec<CorpusId>,
    /* private fields */
}

```

### InMemoryOnDiskCorpus

libafl::corpus::inmemory_ondisk::InMemoryOnDiskCorpus

一个能够将测试用例存储到磁盘上的语料库，同时也将所有测试用例保留在内存中。元数据默认情况下会写入到同一文件夹下的.<文件名>.metadata文件中。

```rust
pub struct InMemoryOnDiskCorpus<I>
where
    I: Input,
{
    inner: InMemoryCorpus<I>,
    dir_path: PathBuf,
    meta_format: Option<OnDiskMetadataFormat>,
}
```
底层通过`InMemoryCorpus`实现

### OnDiskCorpus

libafl::corpus::ondisk::OnDiskCorpus

一个能够将测试用例存储到磁盘上并在需要时从磁盘加载的语料库。元数据默认情况下会写入到同一文件夹下的.<文件名>.metadata文件中。

```rust
pub struct OnDiskCorpus<I>
where
    I: Input,
{
    /// The root directory backing this corpus
    dir_path: PathBuf,
    /// We wrapp a cached corpus and set its size to 1.
    inner: CachedOnDiskCorpus<I>,
}
```
底层通过`CachedOnDiskCorpus`实现

# mutators

```rust
pub trait Mutator<I, S> {
    // Required method
    fn mutate(
        &mut self,
        state: &mut S,
        input: &mut I,
        stage_idx: i32
    ) -> Result<MutationResult, Error>;

    // Provided method
    fn post_exec(
        &mut self,
        _state: &mut S,
        _stage_idx: i32,
        _corpus_idx: Option<CorpusId>
    ) -> Result<(), Error> { ... }
}
```

## 常见的mutators

###  BitFlipMutator

libafl::mutators::mutations::BitFlipMutator

翻转byte中的随机bit位

```rust
impl<I, S> Mutator<I, S> for BitFlipMutator
where
    S: HasRand,
    I: HasBytesVec,
{
    fn mutate(
        &mut self,
        state: &mut S,
        input: &mut I,
        _stage_idx: i32,
    ) -> Result<MutationResult, Error> {
        if input.bytes().is_empty() {
            Ok(MutationResult::Skipped)
        } else {
            // 从0..8中随机选择一个bit位
            let bit = 1 << state.rand_mut().choose(0..8);
            // 从input中随机选择一个byte
            let byte = state.rand_mut().choose(input.bytes_mut());
            // 翻转bit位
            *byte ^= bit;
            Ok(MutationResult::Mutated)
        }
    }
}
```

### ByteAddMutator

libafl::mutators::mutations::ByteAddMutator

在一个 Vec 中的随机位置，以随机字节顺序，将一个随机值（范围在 ARITH_MAX 内）加或减到 [<$size>] 大小的元素上。

通过`add_mutator_impl`宏实现

```rust
add_mutator_impl!(ByteAddMutator, u8);
```

`add_mutator_impl`宏实现原理

```rust
// Helper macro that defines the arithmetic addition/subtraction mutations where random slices
// within the input are treated as u8, u16, u32, or u64, then mutated in place.
macro_rules! add_mutator_impl {
    ($name: ident, $size: ty) => {
        /// Adds or subtracts a random value up to `ARITH_MAX` to a [`<$size>`] at a random place in the [`Vec`], in random byte order.
        #[derive(Default, Debug)]
        pub struct $name;

        #[allow(trivial_numeric_casts)]
        impl<I, S> Mutator<I, S> for $name
        where
            S: HasRand,
            I: HasBytesVec,
        {
            fn mutate(
                &mut self,
                state: &mut S,
                input: &mut I,
                _stage_idx: i32,
            ) -> Result<MutationResult, Error> {
                // 防止越界
                if input.bytes().len() < size_of::<$size>() {
                    Ok(MutationResult::Skipped)
                } else {
                    // choose a random window of bytes (windows overlap) and convert to $size
                    // 从input中随机选择一个byte
                    let (index, bytes) = state
                        .rand_mut()
                        .choose(input.bytes().windows(size_of::<$size>()).enumerate());
                    // 将bytes转换为$size
                    let val = <$size>::from_ne_bytes(bytes.try_into().unwrap());

                    // mutate
                    // 从0..ARITH_MAX中随机选择一个数
                    let num = 1 + state.rand_mut().below(ARITH_MAX) as $size;
                    let new_val = match state.rand_mut().below(4) {
                        // 加或减
                        0 => val.wrapping_add(num),
                        1 => val.wrapping_sub(num),
                        // 大小段转换 加或减
                        2 => val.swap_bytes().wrapping_add(num).swap_bytes(),
                        _ => val.swap_bytes().wrapping_sub(num).swap_bytes(),
                    };

                    // set bytes to mutated value
                    // 保存突变后的值
                    let new_bytes = &mut input.bytes_mut()[index..index + size_of::<$size>()];
                    new_bytes.copy_from_slice(&new_val.to_ne_bytes());
                    Ok(MutationResult::Mutated)
                }
            }
        }

        impl Named for $name {
            fn name(&self) -> &str {
                stringify!($name)
            }
        }

        impl $name {
            /// Creates a new [`$name`].
            #[must_use]
            pub fn new() -> Self {
                Self
            }
        }
    };
}
```

### ByteDecMutator

libafl::mutators::mutations::ByteDecMutator

对于带有字节向量（bytes vector）的输入的字节递减突变操作

```rust
impl<I, S> Mutator<I, S> for ByteDecMutator
where
    S: HasRand,
    I: HasBytesVec,
{
    fn mutate(
        &mut self,
        state: &mut S,
        input: &mut I,
        _stage_idx: i32,
    ) -> Result<MutationResult, Error> {
        if input.bytes().is_empty() {
            Ok(MutationResult::Skipped)
        } else {
            // 从input中随机选择一个byte
            let byte = state.rand_mut().choose(input.bytes_mut());
            // 减1
            *byte = byte.wrapping_sub(1);
            Ok(MutationResult::Mutated)
        }
    }
}
```

### ByteFlipMutator

libafl::mutators::mutations::ByteFlipMutator

随机byte翻转

```rust
impl<I, S> Mutator<I, S> for ByteFlipMutator
where
    S: HasRand,
    I: HasBytesVec,
{
    fn mutate(
        &mut self,
        state: &mut S,
        input: &mut I,
        _stage_idx: i32,
    ) -> Result<MutationResult, Error> {
        if input.bytes().is_empty() {
            Ok(MutationResult::Skipped)
        } else {
            // 从input中随机选择一个byte，并翻转
            *state.rand_mut().choose(input.bytes_mut()) ^= 0xff;
            Ok(MutationResult::Mutated)
        }
    }
}
```

### ByteIncMutator

libafl::mutators::mutations::ByteIncMutator

随机byte递增

```rust
/// Byte increment mutation for inputs with a bytes vector
#[derive(Default, Debug)]
pub struct ByteIncMutator;

impl<I, S> Mutator<I, S> for ByteIncMutator
where
    S: HasRand,
    I: HasBytesVec,
{
    fn mutate(
        &mut self,
        state: &mut S,
        input: &mut I,
        _stage_idx: i32,
    ) -> Result<MutationResult, Error> {
        if input.bytes().is_empty() {
            Ok(MutationResult::Skipped)
        } else {
            // 从input中随机选择一个byte，并加1
            let byte = state.rand_mut().choose(input.bytes_mut());
            *byte = byte.wrapping_add(1);
            Ok(MutationResult::Mutated)
        }
    }
}
```

### ByteInterestingMutator

libafl::mutators::mutations::ByteInterestingMutator

在输入的随机位置插入一个interesting的值 (通常这个值会导致程序崩溃)

通过`interesting_mutator_impl`宏实现

```rust
interesting_mutator_impl!(ByteInterestingMutator, u8, INTERESTING_8);
```

`interesting_mutator_impl`宏实现原理

```rust
macro_rules! interesting_mutator_impl {
    ($name: ident, $size: ty, $interesting: ident) => {
        /// Inserts an interesting value at a random place in the input vector
        #[derive(Default, Debug)]
        pub struct $name;

        impl<I, S> Mutator<I, S> for $name
        where
            S: HasRand,
            I: HasBytesVec,
        {
            #[allow(clippy::cast_sign_loss)]
            fn mutate(
                &mut self,
                state: &mut S,
                input: &mut I,
                _stage_idx: i32,
            ) -> Result<MutationResult, Error> {
                if input.bytes().len() < size_of::<$size>() {
                    Ok(MutationResult::Skipped)
                } else {
                    let bytes = input.bytes_mut();
                    // 确定数组上界，防止越界
                    let upper_bound = (bytes.len() + 1 - size_of::<$size>()) as u64;
                    // 从0..upper_bound中随机选择一个位置
                    let idx = state.rand_mut().below(upper_bound) as usize;
                    // 从0..interesting中随机选择一个值
                    let val = *state.rand_mut().choose(&$interesting) as $size;
                    // 随机变为大端或小端
                    let new_bytes = match state.rand_mut().choose(&[0, 1]) {
                        0 => val.to_be_bytes(),
                        _ => val.to_le_bytes(),
                    };
                    // 将new_bytes插入到bytes中
                    bytes[idx..idx + size_of::<$size>()].copy_from_slice(&new_bytes);
                    Ok(MutationResult::Mutated)
                }
            }
        }

        impl Named for $name {
            fn name(&self) -> &str {
                stringify!($name)
            }
        }

        impl $name {
            /// Creates a new [`$name`].
            #[must_use]
            pub fn new() -> Self {
                Self
            }
        }
    };
}
```

### ByteNegMutator

libafl::mutators::mutations::ByteNegMutator

对于带有字节向量（bytes vector）的输入的字节符号取反突变操作

```rust
impl<I, S> Mutator<I, S> for ByteNegMutator
where
    S: HasRand,
    I: HasBytesVec,
{
    fn mutate(
        &mut self,
        state: &mut S,
        input: &mut I,
        _stage_idx: i32,
    ) -> Result<MutationResult, Error> {
        if input.bytes().is_empty() {
            Ok(MutationResult::Skipped)
        } else {
            let byte = state.rand_mut().choose(input.bytes_mut());
            // -a=~a+1
            *byte = (!(*byte)).wrapping_add(1);
            Ok(MutationResult::Mutated)
        }
    }
}
```

### ByteRandMutator

libafl::mutators::mutations::ByteRandMutator

byte随机变化

```rust
impl<I, S> Mutator<I, S> for ByteRandMutator
where
    S: HasRand,
    I: HasBytesVec,
{
    fn mutate(
        &mut self,
        state: &mut S,
        input: &mut I,
        _stage_idx: i32,
    ) -> Result<MutationResult, Error> {
        if input.bytes().is_empty() {
            Ok(MutationResult::Skipped)
        } else {
            let byte = state.rand_mut().choose(input.bytes_mut());
            *byte ^= 1 + state.rand_mut().below(254) as u8;
            Ok(MutationResult::Mutated)
        }
    }
}
```

### BytesCopyMutator

libafl::mutators::mutations::BytesCopyMutator

随机复制一段bytes到另一段bytes

```rust
impl<I, S> Mutator<I, S> for BytesCopyMutator
where
    S: HasRand,
    I: HasBytesVec,
{
    fn mutate(
        &mut self,
        state: &mut S,
        input: &mut I,
        _stage_idx: i32,
    ) -> Result<MutationResult, Error> {
        let size = input.bytes().len();
        if size <= 1 {
            return Ok(MutationResult::Skipped);
        }

        let target = state.rand_mut().below(size as u64) as usize;
        let range = rand_range(state, size, size - target);

        unsafe {
            buffer_self_copy(input.bytes_mut(), range.start, target, range.len());
        }

        Ok(MutationResult::Mutated)
    }
}
```

### BytesDeleteMutator

libafl::mutators::mutations::BytesDeleteMutator

随机删除一段bytes

```rust
impl<I, S> Mutator<I, S> for BytesDeleteMutator
where
    S: HasRand,
    I: HasBytesVec,
{
    fn mutate(
        &mut self,
        state: &mut S,
        input: &mut I,
        _stage_idx: i32,
    ) -> Result<MutationResult, Error> {
        let size = input.bytes().len();
        if size <= 2 {
            return Ok(MutationResult::Skipped);
        }

        let range = rand_range(state, size, size);

        input.bytes_mut().drain(range);

        Ok(MutationResult::Mutated)
    }
}
```

### BytesExpandMutator

libafl::mutators::mutations::BytesExpandMutator

随机扩展一段bytes

```rust
impl<I, S> Mutator<I, S> for BytesExpandMutator
where
    S: HasRand + HasMaxSize,
    I: HasBytesVec,
{
    fn mutate(
        &mut self,
        state: &mut S,
        input: &mut I,
        _stage_idx: i32,
    ) -> Result<MutationResult, Error> {
        let max_size = state.max_size();
        let size = input.bytes().len();
        if size == 0 || size >= max_size {
            return Ok(MutationResult::Skipped);
        }

        let range = rand_range(state, size, min(16, max_size - size));

        input.bytes_mut().resize(size + range.len(), 0);
        unsafe {
            buffer_self_copy(
                input.bytes_mut(),
                range.start,
                range.start + range.len(),
                size - range.start,
            );
        }

        Ok(MutationResult::Mutated)
    }
}
```

### BytesInsertCopyMutator

libafl::mutators::mutations::BytesInsertCopyMutator

随机复制一段bytes插入到另一段bytes的随机位置

```rust
impl<I, S> Mutator<I, S> for BytesInsertCopyMutator
where
    S: HasRand + HasMaxSize,
    I: HasBytesVec,
{
    fn mutate(
        &mut self,
        state: &mut S,
        input: &mut I,
        _stage_idx: i32,
    ) -> Result<MutationResult, Error> {
        let size = input.bytes().len();
        if size <= 1 || size >= state.max_size() {
            return Ok(MutationResult::Skipped);
        }

        let target = state.rand_mut().below(size as u64) as usize;
        // make sure that the sampled range is both in bounds and of an acceptable size
        let max_insert_len = min(size - target, state.max_size() - size);
        let range = rand_range(state, size, min(16, max_insert_len));

        input.bytes_mut().resize(size + range.len(), 0);
        self.tmp_buf.resize(range.len(), 0);
        unsafe {
            // 将input从start开始长度为len的buf拷贝到tmp_buf[0]中
            buffer_copy(
                &mut self.tmp_buf,
                input.bytes(),
                range.start,
                0,
                range.len(),
            );

            buffer_self_copy(
                input.bytes_mut(),
                target,
                target + range.len(),
                size - target,
            );
            buffer_copy(input.bytes_mut(), &self.tmp_buf, 0, target, range.len());
        }
        Ok(MutationResult::Mutated)
    }
}
```

### BytesInsertMutator

libafl::mutators::mutations::BytesInsertMutator

随机插入一段bytes（随机从buf中选取）

```rust
impl<I, S> Mutator<I, S> for BytesInsertMutator
where
    S: HasRand + HasMaxSize,
    I: HasBytesVec,
{
    fn mutate(
        &mut self,
        state: &mut S,
        input: &mut I,
        _stage_idx: i32,
    ) -> Result<MutationResult, Error> {
        let max_size = state.max_size();
        let size = input.bytes().len();
        if size == 0 || size >= max_size {
            return Ok(MutationResult::Skipped);
        }

        let mut amount = 1 + state.rand_mut().below(16) as usize;
        let offset = state.rand_mut().below(size as u64 + 1) as usize;

        if size + amount > max_size {
            if max_size > size {
                amount = max_size - size;
            } else {
                return Ok(MutationResult::Skipped);
            }
        }
        // 随机从input中选择一个byte
        let val = input.bytes()[state.rand_mut().below(size as u64) as usize];

        input.bytes_mut().resize(size + amount, 0);
        unsafe {
            buffer_self_copy(input.bytes_mut(), offset, offset + amount, size - offset);
        }
        buffer_set(input.bytes_mut(), offset, amount, val);

        Ok(MutationResult::Mutated)
    }
}
```

### BytesRandInsertMutator

libafl::mutators::mutations::BytesRandInsertMutator

随机插入一段bytes（0到255）

```rust
impl<I, S> Mutator<I, S> for BytesRandInsertMutator
where
    S: HasRand + HasMaxSize,
    I: HasBytesVec,
{
    fn mutate(
        &mut self,
        state: &mut S,
        input: &mut I,
        _stage_idx: i32,
    ) -> Result<MutationResult, Error> {
        let max_size = state.max_size();
        let size = input.bytes().len();
        if size >= max_size {
            return Ok(MutationResult::Skipped);
        }

        let mut amount = 1 + state.rand_mut().below(16) as usize;
        let offset = state.rand_mut().below(size as u64 + 1) as usize;

        if size + amount > max_size {
            if max_size > size {
                amount = max_size - size;
            } else {
                return Ok(MutationResult::Skipped);
            }
        }
        // 从0..255中随机选择一个数
        let val = state.rand_mut().next() as u8;

        input.bytes_mut().resize(size + amount, 0);
        unsafe {
            buffer_self_copy(input.bytes_mut(), offset, offset + amount, size - offset);
        }
        buffer_set(input.bytes_mut(), offset, amount, val);

        Ok(MutationResult::Mutated)
    }
}
```

### BytesRandSetMutator

libafl::mutators::mutations::BytesRandSetMutator

随机设置buf，值为随机值（0到255）

```rust
impl<I, S> Mutator<I, S> for BytesRandSetMutator
where
    S: HasRand,
    I: HasBytesVec,
{
    fn mutate(
        &mut self,
        state: &mut S,
        input: &mut I,
        _stage_idx: i32,
    ) -> Result<MutationResult, Error> {
        let size = input.bytes().len();
        if size == 0 {
            return Ok(MutationResult::Skipped);
        }
        let range = rand_range(state, size, min(size, 16));

        let val = state.rand_mut().next() as u8;
        let quantity = range.len();
        buffer_set(input.bytes_mut(), range.start, quantity, val);

        Ok(MutationResult::Mutated)
    }
}
```

### BytesSetMutator

libafl::mutators::mutations::BytesSetMutator

随机设置buf，值为随机值（从buf中随机选取）

```rust
impl<I, S> Mutator<I, S> for BytesSetMutator
where
    S: HasRand,
    I: HasBytesVec,
{
    fn mutate(
        &mut self,
        state: &mut S,
        input: &mut I,
        _stage_idx: i32,
    ) -> Result<MutationResult, Error> {
        let size = input.bytes().len();
        if size == 0 {
            return Ok(MutationResult::Skipped);
        }
        let range = rand_range(state, size, min(size, 16));

        let val = *state.rand_mut().choose(input.bytes());
        let quantity = range.len();
        buffer_set(input.bytes_mut(), range.start, quantity, val);

        Ok(MutationResult::Mutated)
    }
}
```

### BytesSwapMutator

libafl::mutators::mutations::BytesSwapMutator

逐字节随机交换两段buf

```rust
#[allow(clippy::too_many_lines)]
impl<I, S> Mutator<I, S> for BytesSwapMutator
where
    S: HasRand,
    I: HasBytesVec,
{
    fn mutate(
        &mut self,
        state: &mut S,
        input: &mut I,
        _stage_idx: i32,
    ) -> Result<MutationResult, Error> {
        let size = input.bytes().len();
        if size <= 1 {
            return Ok(MutationResult::Skipped);
        }

        let first = rand_range(state, size, size);
        if state.rand_mut().next() & 1 == 0 && first.start != 0 {
            // The second range comes before first.

            let second = rand_range(state, first.start, first.start);
            self.tmp_buf.resize(first.len(), 0);
            unsafe {
                // If range first is larger
                if first.len() >= second.len() {
                    let diff_in_size = first.len() - second.len();

                    // copy first range to tmp
                    buffer_copy(
                        &mut self.tmp_buf,
                        input.bytes(),
                        first.start,
                        0,
                        first.len(),
                    );

                    // adjust second.end..first.start, move them by diff_in_size to the right
                    buffer_self_copy(
                        input.bytes_mut(),
                        second.end,
                        second.end + diff_in_size,
                        first.start - second.end,
                    );

                    // copy second to where first was
                    buffer_self_copy(
                        input.bytes_mut(),
                        second.start,
                        first.start + diff_in_size,
                        second.len(),
                    );

                    // copy first back
                    buffer_copy(
                        input.bytes_mut(),
                        &self.tmp_buf,
                        0,
                        second.start,
                        first.len(),
                    );
                } else {
                    let diff_in_size = second.len() - first.len();

                    // copy first range to tmp
                    buffer_copy(
                        &mut self.tmp_buf,
                        input.bytes(),
                        first.start,
                        0,
                        first.len(),
                    );

                    // adjust second.end..first.start, move them by diff_in_size to the left
                    buffer_self_copy(
                        input.bytes_mut(),
                        second.end,
                        second.end - diff_in_size,
                        first.start - second.end,
                    );

                    // copy second to where first was
                    buffer_self_copy(
                        input.bytes_mut(),
                        second.start,
                        first.start - diff_in_size,
                        second.len(),
                    );

                    // copy first back
                    buffer_copy(
                        input.bytes_mut(),
                        &self.tmp_buf,
                        0,
                        second.start,
                        first.len(),
                    );
                }
            }
            Ok(MutationResult::Mutated)
        } else if first.end != size {
            // The first range comes before the second range
            let mut second = rand_range(state, size - first.end, size - first.end);
            second.start += first.end;
            second.end += first.end;

            self.tmp_buf.resize(second.len(), 0);
            unsafe {
                if second.len() >= first.len() {
                    let diff_in_size = second.len() - first.len();
                    // copy second range to tmp
                    buffer_copy(
                        &mut self.tmp_buf,
                        input.bytes(),
                        second.start,
                        0,
                        second.len(),
                    );

                    // adjust first.end..second.start, move them by diff_in_size to the right
                    buffer_self_copy(
                        input.bytes_mut(),
                        first.end,
                        first.end + diff_in_size,
                        second.start - first.end,
                    );

                    // copy first to where second was
                    buffer_self_copy(
                        input.bytes_mut(),
                        first.start,
                        second.start + diff_in_size,
                        first.len(),
                    );

                    // copy second back
                    buffer_copy(
                        input.bytes_mut(),
                        &self.tmp_buf,
                        0,
                        first.start,
                        second.len(),
                    );
                } else {
                    let diff_in_size = first.len() - second.len();
                    // copy second range to tmp
                    buffer_copy(
                        &mut self.tmp_buf,
                        input.bytes(),
                        second.start,
                        0,
                        second.len(),
                    );

                    // adjust first.end..second.start, move them by diff_in_size to the left
                    buffer_self_copy(
                        input.bytes_mut(),
                        first.end,
                        first.end - diff_in_size,
                        second.start - first.end,
                    );

                    // copy first to where second was
                    buffer_self_copy(
                        input.bytes_mut(),
                        first.start,
                        second.start - diff_in_size,
                        first.len(),
                    );

                    // copy second back
                    buffer_copy(
                        input.bytes_mut(),
                        &self.tmp_buf,
                        0,
                        first.start,
                        second.len(),
                    );
                }
            }

            Ok(MutationResult::Mutated)
        } else {
            Ok(MutationResult::Skipped)
        }
    }
}
```

### DwordAddMutator

libafl::mutators::mutations::DwordAddMutator

对于带有字节向量（bytes vector）的输入的dword加减突变操作

通过`add_mutator_impl`宏实现，与ByteAddMutator类似，只是操作的是u32

### DwordInterestingMutator

libafl::mutators::mutations::DwordInterestingMutator

对于带有字节向量（bytes vector）的输入的dword插入突变操作

通过`interesting_mutator_impl`宏实现，与ByteInterestingMutator类似，只是操作的是u32

### QwordAddMutator

libafl::mutators::mutations::QwordAddMutator

对于带有字节向量（bytes vector）的输入的qword加减突变操作

通过`add_mutator_impl`宏实现，与ByteAddMutator类似，只是操作的是u64

### WordAddMutator

libafl::mutators::mutations::WordAddMutator

对于带有字节向量（bytes vector）的输入的word加减突变操作

通过`add_mutator_impl`宏实现，与ByteAddMutator类似，只是操作的是u16

### WordInterestingMutator

libafl::mutators::mutations::WordInterestingMutator

对于带有字节向量（bytes vector）的输入的word插入突变操作

通过`interesting_mutator_impl`宏实现，与ByteInterestingMutator类似，只是操作的是u16

### GramatronRandomMutator

libafl::mutators::gramatron::GramatronRandomMutator

随机语法变异器，详情：[`Gramatron`](https://github.com/HexHive/Gramatron)

### StdScheduledMutator

libafl::mutators::scheduled::StdScheduledMutator

一个Mutator，在每次调用时调度其中一个embedded mutations操作。

```rust
pub struct StdScheduledMutator<I, MT, S>
where
    MT: MutatorsTuple<I, S>,
    S: HasRand,
{
    mutations: MT,
    max_stack_pow: u64,
    phantom: PhantomData<(I, S)>,
}
```

### StdMOptMutator

libafl::mutators::mopt_mutator::StdMOptMutator

MOpt主要结构，一个AFL mutator。参见原始MOpt实现 https://github.com/puppet-meteor/MOpt-AFL

```rust
pub struct StdMOptMutator<I, MT, S>
where
    MT: MutatorsTuple<I, S>,
    S: HasRand + HasMetadata + HasCorpus + HasSolutions,
{
    mode: MOptMode,
    finds_before: usize,
    mutations: MT,
    max_stack_pow: u64,
    phantom: PhantomData<(I, S)>,
}
```

### TuneableScheduledMutator

libafl::mutators::tuneable::TuneableScheduledMutator

mutate 函数调用 libafl::mutators::scheduled::ScheduledMutator 的 scheduled_mutate 函数

```rust
/// A [`Mutator`] scheduling multiple [`Mutator`]s for an input.
pub trait ScheduledMutator<I, MT, S>: ComposedByMutations<I, MT, S> + Mutator<I, S>
where
    MT: MutatorsTuple<I, S>,
{
    /// Compute the number of iterations used to apply stacked mutations
    fn iterations(&self, state: &mut S, input: &I) -> u64;

    /// Get the next mutation to apply
    fn schedule(&self, state: &mut S, input: &I) -> MutationId;

    /// New default implementation for mutate.
    /// Implementations must forward mutate() to this method
    fn scheduled_mutate(
        &mut self,
        state: &mut S,
        input: &mut I,
        stage_idx: i32,
    ) -> Result<MutationResult, Error> {
        let mut r = MutationResult::Skipped;
        let num = self.iterations(state, input);
        for _ in 0..num {
            let idx = self.schedule(state, input);
            let outcome = self
                .mutations_mut()
                .get_and_mutate(idx, state, input, stage_idx)?;
            if outcome == MutationResult::Mutated {
                r = MutationResult::Mutated;
            }
        }
        Ok(r)
    }
}
```

### LoggerScheduledMutator

libafl::mutators::scheduled::LoggerScheduledMutator

对于 StdScheduledMutator 的 wraps

# Scheduler

调度程序定义了模糊器如何从语料库中请求测试用例。它具有用于语料库添加/替换/删除的钩子，以允许复杂的调度算法收集数据。

```rust
pub trait Scheduler: UsesState
where
    Self::State: HasCorpus,
{
    // Required methods
    fn on_add(
        &mut self,
        _state: &mut Self::State,
        _idx: CorpusId
    ) -> Result<(), Error>;
    fn next(&mut self, state: &mut Self::State) -> Result<CorpusId, Error>;

    // Provided methods
    fn on_evaluation<OT>(
        &mut self,
        _state: &mut Self::State,
        _input: &<Self::State as UsesInput>::Input,
        _observers: &OT
    ) -> Result<(), Error>
       where OT: ObserversTuple<Self::State> { ... }
    fn set_current_scheduled(
        &mut self,
        state: &mut Self::State,
        next_idx: Option<CorpusId>
    ) -> Result<(), Error> { ... }
}
```

## 常见的Scheduler

### MinimizerScheduler

libafl::schedulers::minimizer::MinimizerScheduler

`MinimizerScheduler` 使用遗传算法来计算一个子集，这个子集包含所有请求的特征（例如，到目前为止看到的所有覆盖范围），并优先考虑使用 `TestcaseScore` 来对测试用例进行排序。

```rust
impl<CS, F, M> MinimizerScheduler<CS, F, M>
where
    CS: Scheduler,
    F: TestcaseScore<CS::State>,
    M: AsSlice<Entry = usize> + SerdeAny + HasRefCnt,
    CS::State: HasCorpus + HasMetadata + HasRand,
{
    /// Update the `Corpus` score using the `MinimizerScheduler`
    #[allow(clippy::unused_self)]
    #[allow(clippy::cast_possible_wrap)]
    pub fn update_score(&self, state: &mut CS::State, idx: CorpusId) -> Result<(), Error> {
        // Create a new top rated meta if not existing
        if state.metadata_map().get::<TopRatedsMetadata>().is_none() {
            state.add_metadata(TopRatedsMetadata::new());
        }

        let mut new_favoreds = vec![];
        {
            // 获取第idx个testcase
            let mut entry = state.corpus().get(idx)?.borrow_mut();
            // 计算第idx个testcase的分数
            let factor = F::compute(state, &mut *entry)?;
            // 获取第idx个testcase的metadata
            let meta = entry.metadata_map_mut().get_mut::<M>().ok_or_else(|| {
                Error::key_not_found(format!(
                    "Metadata needed for MinimizerScheduler not found in testcase #{idx}"
                ))
            })?;

            let top_rateds = state.metadata_map().get::<TopRatedsMetadata>().unwrap();
            for elem in meta.as_slice() {
                if let Some(old_idx) = top_rateds.map.get(elem) {
                    if *old_idx == idx {
                        new_favoreds.push(*elem); // always retain current; we'll drop it later otherwise
                        continue;
                    }
                    // 获取old测试用例
                    let mut old = state.corpus().get(*old_idx)?.borrow_mut();
                    // 如果old的分数小于当前的分数，则删除old
                    if factor > F::compute(state, &mut *old)? {
                        continue;
                    }

                    let must_remove = {
                        let old_meta = old.metadata_map_mut().get_mut::<M>().ok_or_else(|| {
                            Error::key_not_found(format!(
                                "{} needed for MinimizerScheduler not found in testcase #{old_idx}",
                                type_name::<M>()
                            ))
                        })?;
                        // 减少引用计数
                        *old_meta.refcnt_mut() -= 1;
                        // 当引用次数为0时，删除old的metadata
                        old_meta.refcnt() <= 0
                    };

                    if must_remove {
                        drop(old.metadata_map_mut().remove::<M>());
                    }
                }
                // 向new_favoreds中添加*elem
                new_favoreds.push(*elem);
            }

            *meta.refcnt_mut() = new_favoreds.len() as isize;
        }

        if new_favoreds.is_empty() {
            drop(
                state
                    .corpus()
                    .get(idx)?
                    .borrow_mut()
                    .metadata_map_mut()
                    .remove::<M>(),
            );
            return Ok(());
        }
        // 向state中添加insert(elem, idx)
        for elem in new_favoreds {
            state
                .metadata_map_mut()
                .get_mut::<TopRatedsMetadata>()
                .unwrap()
                .map
                .insert(elem, idx);
        }
        Ok(())
    }
}
```

# fuzzer

```rust
pub trait Fuzzer<E, EM, ST>: Sized + UsesState
where
    Self::State: HasClientPerfMonitor + HasMetadata + HasExecutions,
    E: UsesState<State = Self::State>,
    EM: ProgressReporter<State = Self::State>,
    ST: StagesTuple<E, EM, Self::State, Self>,
{
    // Required method
    fn fuzz_one(
        &mut self,
        stages: &mut ST,
        executor: &mut E,
        state: &mut EM::State,
        manager: &mut EM
    ) -> Result<CorpusId, Error>;

    // Provided methods
    fn fuzz_loop(
        &mut self,
        stages: &mut ST,
        executor: &mut E,
        state: &mut EM::State,
        manager: &mut EM
    ) -> Result<CorpusId, Error> { ... }
    fn fuzz_loop_for(
        &mut self,
        stages: &mut ST,
        executor: &mut E,
        state: &mut EM::State,
        manager: &mut EM,
        iters: u64
    ) -> Result<CorpusId, Error> { ... }
}
```

## 常见的fuzzer

目前来说，fuzzer只有一种实现，即StdFuzzer

### StdFuzzer

libafl::fuzzer::StdFuzzer

```rust
pub struct StdFuzzer<CS, F, OF, OT>
where
    CS: Scheduler,
    F: Feedback<CS::State>,
    OF: Feedback<CS::State>,
    CS::State: HasClientPerfMonitor + HasCorpus,
{ /* private fields */ }
```

以`fuzz_loop`函数为例

```rust
fn fuzz_loop(
    &mut self,
    stages: &mut ST,
    executor: &mut E,
    state: &mut EM::State,
    manager: &mut EM,
) -> Result<CorpusId, Error> {
    let mut last = current_time();
    let monitor_timeout = STATS_TIMEOUT_DEFAULT;
    loop {
        // 底层调用fuzz_one实现
        self.fuzz_one(stages, executor, state, manager)?;
        // ProgressReporter向broker报告进度
        last = manager.maybe_report_progress(state, last, monitor_timeout)?;
    }
}
```

`fuzz_one`函数

进行一次模糊迭代。返回最后一个模糊过的语料库项的索引。（注意：一个迭代代表每个阶段的完整运行。因此，它并不意味着执行了一次目标的测试用例，因为每个阶段可能会运行多次目标的测试用例。）

```rust
impl<CS, E, EM, F, OF, OT, ST> Fuzzer<E, EM, ST> for StdFuzzer<CS, F, OF, OT>
where
    CS: Scheduler,
    E: UsesState<State = CS::State>,
    EM: ProgressReporter + EventProcessor<E, Self, State = CS::State>,
    F: Feedback<CS::State>,
    OF: Feedback<CS::State>,
    CS::State: HasClientPerfMonitor + HasExecutions + HasMetadata + HasCorpus + HasTestcase,
    ST: StagesTuple<E, EM, CS::State, Self>,
{
    fn fuzz_one(
        &mut self,
        stages: &mut ST,
        executor: &mut E,
        state: &mut CS::State,
        manager: &mut EM,
    ) -> Result<CorpusId, Error> {
        // Init timer for scheduler
        #[cfg(feature = "introspection")]
        state.introspection_monitor_mut().start_timer();

        // Get the next index from the scheduler
        let idx = self.scheduler.next(state)?;

        // Mark the elapsed time for the scheduler
        #[cfg(feature = "introspection")]
        state.introspection_monitor_mut().mark_scheduler_time();

        // Mark the elapsed time for the scheduler
        #[cfg(feature = "introspection")]
        state.introspection_monitor_mut().reset_stage_index();

        // Execute all stages
        stages.perform_all(self, executor, state, manager, idx)?;

        // Init timer for manager
        #[cfg(feature = "introspection")]
        state.introspection_monitor_mut().start_timer();

        // Execute the manager
        manager.process(self, state, executor)?;

        // Mark the elapsed time for the manager
        #[cfg(feature = "introspection")]
        state.introspection_monitor_mut().mark_manager_time();

        {
            let mut testcase = state.testcase_mut(idx)?;
            let scheduled_count = testcase.scheduled_count();

            // increase scheduled count, this was fuzz_level in afl
            testcase.set_scheduled_count(scheduled_count + 1);
        }

        Ok(idx)
    }
}
```

在忽略掉`#[cfg(feature = "introspection")]`相关代码后，可以发现 `fuzz_one`函数的主要逻辑是：

1. 从scheduler.next 中获取下一个测试用例的id
2. stages.perform_all 执行所有的阶段
3. manager.process 执行manager
4. count + 1

next 函数

```rust
pub trait Scheduler: UsesState
where
    Self::State: HasCorpus,
{
    /// Gets the next entry
    fn next(&mut self, state: &mut Self::State) -> Result<CorpusId, Error>;
}
```

perform_all 函数

```rust
/// A tuple holding all `Stages` used for fuzzing.
pub trait StagesTuple<E, EM, S, Z>
where
    E: UsesState<State = S>,
    EM: UsesState<State = S>,
    Z: UsesState<State = S>,
    S: UsesInput,
{
    /// Performs all `Stages` in this tuple
    fn perform_all(
        &mut self,
        fuzzer: &mut Z,
        executor: &mut E,
        state: &mut S,
        manager: &mut EM,
        corpus_idx: CorpusId,
    ) -> Result<(), Error>;
}
```

process 函数

```rust
pub trait EventProcessor<E, Z>: UsesState {
    // Required method
    fn process(
        &mut self,
        fuzzer: &mut Z,
        state: &mut Self::State,
        executor: &mut E
    ) -> Result<usize, Error>;
}
```
