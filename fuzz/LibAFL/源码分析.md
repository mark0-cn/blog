# corpus

```rust
pub trait Corpus: UsesInput + Serialize + for<'de> Deserialize<'de> {
    // Required methods
    fn count(&self) -> usize;
    fn add(
        &mut self,
        testcase: Testcase<Self::Input>
    ) -> Result<CorpusId, Error>;
    fn replace(
        &mut self,
        idx: CorpusId,
        testcase: Testcase<Self::Input>
    ) -> Result<Testcase<Self::Input>, Error>;
    fn remove(&mut self, id: CorpusId) -> Result<Testcase<Self::Input>, Error>;
    fn get(
        &self,
        id: CorpusId
    ) -> Result<&RefCell<Testcase<Self::Input>>, Error>;
    fn current(&self) -> &Option<CorpusId>;
    fn current_mut(&mut self) -> &mut Option<CorpusId>;
    fn next(&self, id: CorpusId) -> Option<CorpusId>;
    fn prev(&self, id: CorpusId) -> Option<CorpusId>;
    fn first(&self) -> Option<CorpusId>;
    fn last(&self) -> Option<CorpusId>;
    fn load_input_into(
        &self,
        testcase: &mut Testcase<Self::Input>
    ) -> Result<(), Error>;
    fn store_input_from(
        &self,
        testcase: &Testcase<Self::Input>
    ) -> Result<(), Error>;

    // Provided methods
    fn is_empty(&self) -> bool { ... }
    fn ids(&self) -> CorpusIdIterator<'_, Self> ⓘ { ... }
    fn nth(&self, nth: usize) -> CorpusId { ... }
    fn cloned_input_for_id(&self, idx: CorpusId) -> Result<Self::Input, Error> { ... }
}
```

## 常见的corpus

底层实现顺序：
InMemoryCorpus->InMemoryOnDiskCorpus->CachedOnDiskCorpus->OnDiskCorpus

### CachedOnDiskCorpus

libafl::corpus::cached::CachedOnDiskCorpus

在内存中保持最大数量的测试用例，并在需要时从磁盘加载它们。驱逐策略采用先进先出（FIFO）方式。

```rust
pub struct CachedOnDiskCorpus<I>
where
    I: Input,
{
    inner: InMemoryOnDiskCorpus<I>,
    cached_indexes: RefCell<VecDeque<CorpusId>>,
    cache_max_len: usize,
}
```
底层实现`InMemoryOnDiskCorpus`

### InMemoryCorpus

libafl::corpus::inmemory::InMemoryCorpus

所有handlding 都储存在内存中

```rust
pub struct InMemoryCorpus<I>
where
    I: Input,
{
    /*
    storage:用于储存测试用例
    current:当前测试用例的id
    */
    storage: TestcaseStorage<I>,
    current: Option<CorpusId>,
}

pub struct TestcaseStorage<I>
where
    I: Input,
{
    /*
    map: TestcaseStorageMap<I>
    The map in which testcases are stored

    keys: Vec<CorpusId>
    The keys in order (use Vec::binary_search)
    */
    pub map: TestcaseStorageMap<I>,
    pub keys: Vec<CorpusId>,
    /* private fields */
}

```

### InMemoryOnDiskCorpus

libafl::corpus::inmemory_ondisk::InMemoryOnDiskCorpus

一个能够将测试用例存储到磁盘上的语料库，同时也将所有测试用例保留在内存中。元数据默认情况下会写入到同一文件夹下的.<文件名>.metadata文件中。

```rust
pub struct InMemoryOnDiskCorpus<I>
where
    I: Input,
{
    inner: InMemoryCorpus<I>,
    dir_path: PathBuf,
    meta_format: Option<OnDiskMetadataFormat>,
}
```
底层通过`InMemoryCorpus`实现

### OnDiskCorpus

libafl::corpus::ondisk::OnDiskCorpus

一个能够将测试用例存储到磁盘上并在需要时从磁盘加载的语料库。元数据默认情况下会写入到同一文件夹下的.<文件名>.metadata文件中。

```rust
pub struct OnDiskCorpus<I>
where
    I: Input,
{
    /// The root directory backing this corpus
    dir_path: PathBuf,
    /// We wrapp a cached corpus and set its size to 1.
    inner: CachedOnDiskCorpus<I>,
}
```
底层通过`CachedOnDiskCorpus`实现

# mutators

```rust
pub trait Mutator<I, S> {
    // Required method
    fn mutate(
        &mut self,
        state: &mut S,
        input: &mut I,
        stage_idx: i32
    ) -> Result<MutationResult, Error>;

    // Provided method
    fn post_exec(
        &mut self,
        _state: &mut S,
        _stage_idx: i32,
        _corpus_idx: Option<CorpusId>
    ) -> Result<(), Error> { ... }
}
```

## 常见的mutators

###  BitFlipMutator

libafl::mutators::mutations::BitFlipMutator

翻转byte中的随机bit位

```rust
impl<I, S> Mutator<I, S> for BitFlipMutator
where
    S: HasRand,
    I: HasBytesVec,
{
    fn mutate(
        &mut self,
        state: &mut S,
        input: &mut I,
        _stage_idx: i32,
    ) -> Result<MutationResult, Error> {
        if input.bytes().is_empty() {
            Ok(MutationResult::Skipped)
        } else {
            // 从0..8中随机选择一个bit位
            let bit = 1 << state.rand_mut().choose(0..8);
            // 从input中随机选择一个byte
            let byte = state.rand_mut().choose(input.bytes_mut());
            // 翻转bit位
            *byte ^= bit;
            Ok(MutationResult::Mutated)
        }
    }
}
```

### ByteAddMutator

libafl::mutators::mutations::ByteAddMutator

在一个 Vec 中的随机位置，以随机字节顺序，将一个随机值（范围在 ARITH_MAX 内）加或减到 [<$size>] 大小的元素上。

通过`add_mutator_impl`宏实现

```rust
add_mutator_impl!(ByteAddMutator, u8);
```

`add_mutator_impl`宏实现原理

```rust
// Helper macro that defines the arithmetic addition/subtraction mutations where random slices
// within the input are treated as u8, u16, u32, or u64, then mutated in place.
macro_rules! add_mutator_impl {
    ($name: ident, $size: ty) => {
        /// Adds or subtracts a random value up to `ARITH_MAX` to a [`<$size>`] at a random place in the [`Vec`], in random byte order.
        #[derive(Default, Debug)]
        pub struct $name;

        #[allow(trivial_numeric_casts)]
        impl<I, S> Mutator<I, S> for $name
        where
            S: HasRand,
            I: HasBytesVec,
        {
            fn mutate(
                &mut self,
                state: &mut S,
                input: &mut I,
                _stage_idx: i32,
            ) -> Result<MutationResult, Error> {
                // 防止越界
                if input.bytes().len() < size_of::<$size>() {
                    Ok(MutationResult::Skipped)
                } else {
                    // choose a random window of bytes (windows overlap) and convert to $size
                    // 从input中随机选择一个byte
                    let (index, bytes) = state
                        .rand_mut()
                        .choose(input.bytes().windows(size_of::<$size>()).enumerate());
                    // 将bytes转换为$size
                    let val = <$size>::from_ne_bytes(bytes.try_into().unwrap());

                    // mutate
                    // 从0..ARITH_MAX中随机选择一个数
                    let num = 1 + state.rand_mut().below(ARITH_MAX) as $size;
                    let new_val = match state.rand_mut().below(4) {
                        // 加或减
                        0 => val.wrapping_add(num),
                        1 => val.wrapping_sub(num),
                        // 大小段转换 加或减
                        2 => val.swap_bytes().wrapping_add(num).swap_bytes(),
                        _ => val.swap_bytes().wrapping_sub(num).swap_bytes(),
                    };

                    // set bytes to mutated value
                    // 保存突变后的值
                    let new_bytes = &mut input.bytes_mut()[index..index + size_of::<$size>()];
                    new_bytes.copy_from_slice(&new_val.to_ne_bytes());
                    Ok(MutationResult::Mutated)
                }
            }
        }

        impl Named for $name {
            fn name(&self) -> &str {
                stringify!($name)
            }
        }

        impl $name {
            /// Creates a new [`$name`].
            #[must_use]
            pub fn new() -> Self {
                Self
            }
        }
    };
}
```

### ByteDecMutator

libafl::mutators::mutations::ByteDecMutator

对于带有字节向量（bytes vector）的输入的字节递减突变操作

```rust
impl<I, S> Mutator<I, S> for ByteDecMutator
where
    S: HasRand,
    I: HasBytesVec,
{
    fn mutate(
        &mut self,
        state: &mut S,
        input: &mut I,
        _stage_idx: i32,
    ) -> Result<MutationResult, Error> {
        if input.bytes().is_empty() {
            Ok(MutationResult::Skipped)
        } else {
            // 从input中随机选择一个byte
            let byte = state.rand_mut().choose(input.bytes_mut());
            // 减1
            *byte = byte.wrapping_sub(1);
            Ok(MutationResult::Mutated)
        }
    }
}
```

### ByteFlipMutator

libafl::mutators::mutations::ByteFlipMutator

随机byte翻转

```rust
impl<I, S> Mutator<I, S> for ByteFlipMutator
where
    S: HasRand,
    I: HasBytesVec,
{
    fn mutate(
        &mut self,
        state: &mut S,
        input: &mut I,
        _stage_idx: i32,
    ) -> Result<MutationResult, Error> {
        if input.bytes().is_empty() {
            Ok(MutationResult::Skipped)
        } else {
            // 从input中随机选择一个byte，并翻转
            *state.rand_mut().choose(input.bytes_mut()) ^= 0xff;
            Ok(MutationResult::Mutated)
        }
    }
}
```

### ByteIncMutator

libafl::mutators::mutations::ByteIncMutator

随机byte递增

```rust
/// Byte increment mutation for inputs with a bytes vector
#[derive(Default, Debug)]
pub struct ByteIncMutator;

impl<I, S> Mutator<I, S> for ByteIncMutator
where
    S: HasRand,
    I: HasBytesVec,
{
    fn mutate(
        &mut self,
        state: &mut S,
        input: &mut I,
        _stage_idx: i32,
    ) -> Result<MutationResult, Error> {
        if input.bytes().is_empty() {
            Ok(MutationResult::Skipped)
        } else {
            // 从input中随机选择一个byte，并加1
            let byte = state.rand_mut().choose(input.bytes_mut());
            *byte = byte.wrapping_add(1);
            Ok(MutationResult::Mutated)
        }
    }
}
```

### ByteInterestingMutator

libafl::mutators::mutations::ByteInterestingMutator

在输入的随机位置插入一个interesting的值 (通常这个值会导致程序崩溃)

通过`interesting_mutator_impl`宏实现

```rust
interesting_mutator_impl!(ByteInterestingMutator, u8, INTERESTING_8);
```

`interesting_mutator_impl`宏实现原理

```rust
macro_rules! interesting_mutator_impl {
    ($name: ident, $size: ty, $interesting: ident) => {
        /// Inserts an interesting value at a random place in the input vector
        #[derive(Default, Debug)]
        pub struct $name;

        impl<I, S> Mutator<I, S> for $name
        where
            S: HasRand,
            I: HasBytesVec,
        {
            #[allow(clippy::cast_sign_loss)]
            fn mutate(
                &mut self,
                state: &mut S,
                input: &mut I,
                _stage_idx: i32,
            ) -> Result<MutationResult, Error> {
                if input.bytes().len() < size_of::<$size>() {
                    Ok(MutationResult::Skipped)
                } else {
                    let bytes = input.bytes_mut();
                    // 确定数组上界，防止越界
                    let upper_bound = (bytes.len() + 1 - size_of::<$size>()) as u64;
                    // 从0..upper_bound中随机选择一个位置
                    let idx = state.rand_mut().below(upper_bound) as usize;
                    // 从0..interesting中随机选择一个值
                    let val = *state.rand_mut().choose(&$interesting) as $size;
                    // 随机变为大端或小端
                    let new_bytes = match state.rand_mut().choose(&[0, 1]) {
                        0 => val.to_be_bytes(),
                        _ => val.to_le_bytes(),
                    };
                    // 将new_bytes插入到bytes中
                    bytes[idx..idx + size_of::<$size>()].copy_from_slice(&new_bytes);
                    Ok(MutationResult::Mutated)
                }
            }
        }

        impl Named for $name {
            fn name(&self) -> &str {
                stringify!($name)
            }
        }

        impl $name {
            /// Creates a new [`$name`].
            #[must_use]
            pub fn new() -> Self {
                Self
            }
        }
    };
}
```

### ByteNegMutator

libafl::mutators::mutations::ByteNegMutator

对于带有字节向量（bytes vector）的输入的字节符号取反突变操作

```rust
impl<I, S> Mutator<I, S> for ByteNegMutator
where
    S: HasRand,
    I: HasBytesVec,
{
    fn mutate(
        &mut self,
        state: &mut S,
        input: &mut I,
        _stage_idx: i32,
    ) -> Result<MutationResult, Error> {
        if input.bytes().is_empty() {
            Ok(MutationResult::Skipped)
        } else {
            let byte = state.rand_mut().choose(input.bytes_mut());
            // -a=~a+1
            *byte = (!(*byte)).wrapping_add(1);
            Ok(MutationResult::Mutated)
        }
    }
}
```

### ByteRandMutator

libafl::mutators::mutations::ByteRandMutator

byte随机变化

```rust
impl<I, S> Mutator<I, S> for ByteRandMutator
where
    S: HasRand,
    I: HasBytesVec,
{
    fn mutate(
        &mut self,
        state: &mut S,
        input: &mut I,
        _stage_idx: i32,
    ) -> Result<MutationResult, Error> {
        if input.bytes().is_empty() {
            Ok(MutationResult::Skipped)
        } else {
            let byte = state.rand_mut().choose(input.bytes_mut());
            *byte ^= 1 + state.rand_mut().below(254) as u8;
            Ok(MutationResult::Mutated)
        }
    }
}
```

### BytesCopyMutator

libafl::mutators::mutations::BytesCopyMutator

随机复制一段bytes到另一段bytes

```rust
impl<I, S> Mutator<I, S> for BytesCopyMutator
where
    S: HasRand,
    I: HasBytesVec,
{
    fn mutate(
        &mut self,
        state: &mut S,
        input: &mut I,
        _stage_idx: i32,
    ) -> Result<MutationResult, Error> {
        let size = input.bytes().len();
        if size <= 1 {
            return Ok(MutationResult::Skipped);
        }

        let target = state.rand_mut().below(size as u64) as usize;
        let range = rand_range(state, size, size - target);

        unsafe {
            buffer_self_copy(input.bytes_mut(), range.start, target, range.len());
        }

        Ok(MutationResult::Mutated)
    }
}
```

### BytesDeleteMutator

libafl::mutators::mutations::BytesDeleteMutator

随机删除一段bytes

```rust
impl<I, S> Mutator<I, S> for BytesDeleteMutator
where
    S: HasRand,
    I: HasBytesVec,
{
    fn mutate(
        &mut self,
        state: &mut S,
        input: &mut I,
        _stage_idx: i32,
    ) -> Result<MutationResult, Error> {
        let size = input.bytes().len();
        if size <= 2 {
            return Ok(MutationResult::Skipped);
        }

        let range = rand_range(state, size, size);

        input.bytes_mut().drain(range);

        Ok(MutationResult::Mutated)
    }
}
```

### BytesExpandMutator

libafl::mutators::mutations::BytesExpandMutator

随机扩展一段bytes

```rust
impl<I, S> Mutator<I, S> for BytesExpandMutator
where
    S: HasRand + HasMaxSize,
    I: HasBytesVec,
{
    fn mutate(
        &mut self,
        state: &mut S,
        input: &mut I,
        _stage_idx: i32,
    ) -> Result<MutationResult, Error> {
        let max_size = state.max_size();
        let size = input.bytes().len();
        if size == 0 || size >= max_size {
            return Ok(MutationResult::Skipped);
        }

        let range = rand_range(state, size, min(16, max_size - size));

        input.bytes_mut().resize(size + range.len(), 0);
        unsafe {
            buffer_self_copy(
                input.bytes_mut(),
                range.start,
                range.start + range.len(),
                size - range.start,
            );
        }

        Ok(MutationResult::Mutated)
    }
}
```

### BytesInsertCopyMutator

libafl::mutators::mutations::BytesInsertCopyMutator

随机复制一段bytes插入到另一段bytes的随机位置

```rust
impl<I, S> Mutator<I, S> for BytesInsertCopyMutator
where
    S: HasRand + HasMaxSize,
    I: HasBytesVec,
{
    fn mutate(
        &mut self,
        state: &mut S,
        input: &mut I,
        _stage_idx: i32,
    ) -> Result<MutationResult, Error> {
        let size = input.bytes().len();
        if size <= 1 || size >= state.max_size() {
            return Ok(MutationResult::Skipped);
        }

        let target = state.rand_mut().below(size as u64) as usize;
        // make sure that the sampled range is both in bounds and of an acceptable size
        let max_insert_len = min(size - target, state.max_size() - size);
        let range = rand_range(state, size, min(16, max_insert_len));

        input.bytes_mut().resize(size + range.len(), 0);
        self.tmp_buf.resize(range.len(), 0);
        unsafe {
            // 将input从start开始长度为len的buf拷贝到tmp_buf[0]中
            buffer_copy(
                &mut self.tmp_buf,
                input.bytes(),
                range.start,
                0,
                range.len(),
            );

            buffer_self_copy(
                input.bytes_mut(),
                target,
                target + range.len(),
                size - target,
            );
            buffer_copy(input.bytes_mut(), &self.tmp_buf, 0, target, range.len());
        }
        Ok(MutationResult::Mutated)
    }
}
```

### BytesInsertMutator

libafl::mutators::mutations::BytesInsertMutator

随机插入一段bytes（随机从buf中选取）

```rust
impl<I, S> Mutator<I, S> for BytesInsertMutator
where
    S: HasRand + HasMaxSize,
    I: HasBytesVec,
{
    fn mutate(
        &mut self,
        state: &mut S,
        input: &mut I,
        _stage_idx: i32,
    ) -> Result<MutationResult, Error> {
        let max_size = state.max_size();
        let size = input.bytes().len();
        if size == 0 || size >= max_size {
            return Ok(MutationResult::Skipped);
        }

        let mut amount = 1 + state.rand_mut().below(16) as usize;
        let offset = state.rand_mut().below(size as u64 + 1) as usize;

        if size + amount > max_size {
            if max_size > size {
                amount = max_size - size;
            } else {
                return Ok(MutationResult::Skipped);
            }
        }
        // 随机从input中选择一个byte
        let val = input.bytes()[state.rand_mut().below(size as u64) as usize];

        input.bytes_mut().resize(size + amount, 0);
        unsafe {
            buffer_self_copy(input.bytes_mut(), offset, offset + amount, size - offset);
        }
        buffer_set(input.bytes_mut(), offset, amount, val);

        Ok(MutationResult::Mutated)
    }
}
```

### BytesRandInsertMutator

libafl::mutators::mutations::BytesRandInsertMutator

随机插入一段bytes（0到255）

```rust
impl<I, S> Mutator<I, S> for BytesRandInsertMutator
where
    S: HasRand + HasMaxSize,
    I: HasBytesVec,
{
    fn mutate(
        &mut self,
        state: &mut S,
        input: &mut I,
        _stage_idx: i32,
    ) -> Result<MutationResult, Error> {
        let max_size = state.max_size();
        let size = input.bytes().len();
        if size >= max_size {
            return Ok(MutationResult::Skipped);
        }

        let mut amount = 1 + state.rand_mut().below(16) as usize;
        let offset = state.rand_mut().below(size as u64 + 1) as usize;

        if size + amount > max_size {
            if max_size > size {
                amount = max_size - size;
            } else {
                return Ok(MutationResult::Skipped);
            }
        }
        // 从0..255中随机选择一个数
        let val = state.rand_mut().next() as u8;

        input.bytes_mut().resize(size + amount, 0);
        unsafe {
            buffer_self_copy(input.bytes_mut(), offset, offset + amount, size - offset);
        }
        buffer_set(input.bytes_mut(), offset, amount, val);

        Ok(MutationResult::Mutated)
    }
}
```

### BytesRandSetMutator

libafl::mutators::mutations::BytesRandSetMutator

随机设置buf，值为随机值（0到255）

```rust
impl<I, S> Mutator<I, S> for BytesRandSetMutator
where
    S: HasRand,
    I: HasBytesVec,
{
    fn mutate(
        &mut self,
        state: &mut S,
        input: &mut I,
        _stage_idx: i32,
    ) -> Result<MutationResult, Error> {
        let size = input.bytes().len();
        if size == 0 {
            return Ok(MutationResult::Skipped);
        }
        let range = rand_range(state, size, min(size, 16));

        let val = state.rand_mut().next() as u8;
        let quantity = range.len();
        buffer_set(input.bytes_mut(), range.start, quantity, val);

        Ok(MutationResult::Mutated)
    }
}
```

### BytesSetMutator

libafl::mutators::mutations::BytesSetMutator

随机设置buf，值为随机值（从buf中随机选取）

```rust
impl<I, S> Mutator<I, S> for BytesSetMutator
where
    S: HasRand,
    I: HasBytesVec,
{
    fn mutate(
        &mut self,
        state: &mut S,
        input: &mut I,
        _stage_idx: i32,
    ) -> Result<MutationResult, Error> {
        let size = input.bytes().len();
        if size == 0 {
            return Ok(MutationResult::Skipped);
        }
        let range = rand_range(state, size, min(size, 16));

        let val = *state.rand_mut().choose(input.bytes());
        let quantity = range.len();
        buffer_set(input.bytes_mut(), range.start, quantity, val);

        Ok(MutationResult::Mutated)
    }
}
```

### BytesSwapMutator

libafl::mutators::mutations::BytesSwapMutator

逐字节随机交换两段buf

```rust
#[allow(clippy::too_many_lines)]
impl<I, S> Mutator<I, S> for BytesSwapMutator
where
    S: HasRand,
    I: HasBytesVec,
{
    fn mutate(
        &mut self,
        state: &mut S,
        input: &mut I,
        _stage_idx: i32,
    ) -> Result<MutationResult, Error> {
        let size = input.bytes().len();
        if size <= 1 {
            return Ok(MutationResult::Skipped);
        }

        let first = rand_range(state, size, size);
        if state.rand_mut().next() & 1 == 0 && first.start != 0 {
            // The second range comes before first.

            let second = rand_range(state, first.start, first.start);
            self.tmp_buf.resize(first.len(), 0);
            unsafe {
                // If range first is larger
                if first.len() >= second.len() {
                    let diff_in_size = first.len() - second.len();

                    // copy first range to tmp
                    buffer_copy(
                        &mut self.tmp_buf,
                        input.bytes(),
                        first.start,
                        0,
                        first.len(),
                    );

                    // adjust second.end..first.start, move them by diff_in_size to the right
                    buffer_self_copy(
                        input.bytes_mut(),
                        second.end,
                        second.end + diff_in_size,
                        first.start - second.end,
                    );

                    // copy second to where first was
                    buffer_self_copy(
                        input.bytes_mut(),
                        second.start,
                        first.start + diff_in_size,
                        second.len(),
                    );

                    // copy first back
                    buffer_copy(
                        input.bytes_mut(),
                        &self.tmp_buf,
                        0,
                        second.start,
                        first.len(),
                    );
                } else {
                    let diff_in_size = second.len() - first.len();

                    // copy first range to tmp
                    buffer_copy(
                        &mut self.tmp_buf,
                        input.bytes(),
                        first.start,
                        0,
                        first.len(),
                    );

                    // adjust second.end..first.start, move them by diff_in_size to the left
                    buffer_self_copy(
                        input.bytes_mut(),
                        second.end,
                        second.end - diff_in_size,
                        first.start - second.end,
                    );

                    // copy second to where first was
                    buffer_self_copy(
                        input.bytes_mut(),
                        second.start,
                        first.start - diff_in_size,
                        second.len(),
                    );

                    // copy first back
                    buffer_copy(
                        input.bytes_mut(),
                        &self.tmp_buf,
                        0,
                        second.start,
                        first.len(),
                    );
                }
            }
            Ok(MutationResult::Mutated)
        } else if first.end != size {
            // The first range comes before the second range
            let mut second = rand_range(state, size - first.end, size - first.end);
            second.start += first.end;
            second.end += first.end;

            self.tmp_buf.resize(second.len(), 0);
            unsafe {
                if second.len() >= first.len() {
                    let diff_in_size = second.len() - first.len();
                    // copy second range to tmp
                    buffer_copy(
                        &mut self.tmp_buf,
                        input.bytes(),
                        second.start,
                        0,
                        second.len(),
                    );

                    // adjust first.end..second.start, move them by diff_in_size to the right
                    buffer_self_copy(
                        input.bytes_mut(),
                        first.end,
                        first.end + diff_in_size,
                        second.start - first.end,
                    );

                    // copy first to where second was
                    buffer_self_copy(
                        input.bytes_mut(),
                        first.start,
                        second.start + diff_in_size,
                        first.len(),
                    );

                    // copy second back
                    buffer_copy(
                        input.bytes_mut(),
                        &self.tmp_buf,
                        0,
                        first.start,
                        second.len(),
                    );
                } else {
                    let diff_in_size = first.len() - second.len();
                    // copy second range to tmp
                    buffer_copy(
                        &mut self.tmp_buf,
                        input.bytes(),
                        second.start,
                        0,
                        second.len(),
                    );

                    // adjust first.end..second.start, move them by diff_in_size to the left
                    buffer_self_copy(
                        input.bytes_mut(),
                        first.end,
                        first.end - diff_in_size,
                        second.start - first.end,
                    );

                    // copy first to where second was
                    buffer_self_copy(
                        input.bytes_mut(),
                        first.start,
                        second.start - diff_in_size,
                        first.len(),
                    );

                    // copy second back
                    buffer_copy(
                        input.bytes_mut(),
                        &self.tmp_buf,
                        0,
                        first.start,
                        second.len(),
                    );
                }
            }

            Ok(MutationResult::Mutated)
        } else {
            Ok(MutationResult::Skipped)
        }
    }
}
```

### DwordAddMutator

libafl::mutators::mutations::DwordAddMutator

对于带有字节向量（bytes vector）的输入的dword加减突变操作

通过`add_mutator_impl`宏实现，与ByteAddMutator类似，只是操作的是u32

### DwordInterestingMutator

libafl::mutators::mutations::DwordInterestingMutator

对于带有字节向量（bytes vector）的输入的dword插入突变操作

通过`interesting_mutator_impl`宏实现，与ByteInterestingMutator类似，只是操作的是u32

### QwordAddMutator

libafl::mutators::mutations::QwordAddMutator

对于带有字节向量（bytes vector）的输入的qword加减突变操作

通过`add_mutator_impl`宏实现，与ByteAddMutator类似，只是操作的是u64

### WordAddMutator

libafl::mutators::mutations::WordAddMutator

对于带有字节向量（bytes vector）的输入的word加减突变操作

通过`add_mutator_impl`宏实现，与ByteAddMutator类似，只是操作的是u16

### WordInterestingMutator

libafl::mutators::mutations::WordInterestingMutator

对于带有字节向量（bytes vector）的输入的word插入突变操作

通过`interesting_mutator_impl`宏实现，与ByteInterestingMutator类似，只是操作的是u16

### GramatronRandomMutator

libafl::mutators::gramatron::GramatronRandomMutator

随机语法变异器，详情：[`Gramatron`](https://github.com/HexHive/Gramatron)

### StdScheduledMutator

libafl::mutators::scheduled::StdScheduledMutator

一个Mutator，在每次调用时调度其中一个embedded mutations操作。

```rust
pub struct StdScheduledMutator<I, MT, S>
where
    MT: MutatorsTuple<I, S>,
    S: HasRand,
{
    mutations: MT,
    max_stack_pow: u64,
    phantom: PhantomData<(I, S)>,
}
```

### StdMOptMutator

libafl::mutators::mopt_mutator::StdMOptMutator

MOpt主要结构，一个AFL mutator。参见原始MOpt实现 https://github.com/puppet-meteor/MOpt-AFL

```rust
pub struct StdMOptMutator<I, MT, S>
where
    MT: MutatorsTuple<I, S>,
    S: HasRand + HasMetadata + HasCorpus + HasSolutions,
{
    mode: MOptMode,
    finds_before: usize,
    mutations: MT,
    max_stack_pow: u64,
    phantom: PhantomData<(I, S)>,
}
```

### TuneableScheduledMutator

libafl::mutators::tuneable::TuneableScheduledMutator

mutate 函数调用 libafl::mutators::scheduled::ScheduledMutator 的 scheduled_mutate 函数

```rust
/// A [`Mutator`] scheduling multiple [`Mutator`]s for an input.
pub trait ScheduledMutator<I, MT, S>: ComposedByMutations<I, MT, S> + Mutator<I, S>
where
    MT: MutatorsTuple<I, S>,
{
    /// Compute the number of iterations used to apply stacked mutations
    fn iterations(&self, state: &mut S, input: &I) -> u64;

    /// Get the next mutation to apply
    fn schedule(&self, state: &mut S, input: &I) -> MutationId;

    /// New default implementation for mutate.
    /// Implementations must forward mutate() to this method
    fn scheduled_mutate(
        &mut self,
        state: &mut S,
        input: &mut I,
        stage_idx: i32,
    ) -> Result<MutationResult, Error> {
        let mut r = MutationResult::Skipped;
        let num = self.iterations(state, input);
        for _ in 0..num {
            let idx = self.schedule(state, input);
            let outcome = self
                .mutations_mut()
                .get_and_mutate(idx, state, input, stage_idx)?;
            if outcome == MutationResult::Mutated {
                r = MutationResult::Mutated;
            }
        }
        Ok(r)
    }
}
```

### LoggerScheduledMutator

libafl::mutators::scheduled::LoggerScheduledMutator

对于 StdScheduledMutator 的 wraps

# Scheduler

调度程序定义了模糊器如何从语料库中请求测试用例。它具有用于语料库添加/替换/删除的钩子，以允许复杂的调度算法收集数据。

```rust
pub trait Scheduler: UsesState
where
    Self::State: HasCorpus,
{
    // Required methods
    fn on_add(
        &mut self,
        _state: &mut Self::State,
        _idx: CorpusId
    ) -> Result<(), Error>;
    fn next(&mut self, state: &mut Self::State) -> Result<CorpusId, Error>;

    // Provided methods
    fn on_evaluation<OT>(
        &mut self,
        _state: &mut Self::State,
        _input: &<Self::State as UsesInput>::Input,
        _observers: &OT
    ) -> Result<(), Error>
       where OT: ObserversTuple<Self::State> { ... }
    fn set_current_scheduled(
        &mut self,
        state: &mut Self::State,
        next_idx: Option<CorpusId>
    ) -> Result<(), Error> { ... }
}
```

## 常见的Scheduler

### MinimizerScheduler

libafl::schedulers::minimizer::MinimizerScheduler

`MinimizerScheduler` 使用遗传算法来计算一个子集，这个子集包含所有请求的特征（例如，到目前为止看到的所有覆盖范围），并优先考虑使用 `TestcaseScore` 来对测试用例进行排序。

```rust
impl<CS, F, M> MinimizerScheduler<CS, F, M>
where
    CS: Scheduler,
    F: TestcaseScore<CS::State>,
    M: AsSlice<Entry = usize> + SerdeAny + HasRefCnt,
    CS::State: HasCorpus + HasMetadata + HasRand,
{
    /// Update the `Corpus` score using the `MinimizerScheduler`
    #[allow(clippy::unused_self)]
    #[allow(clippy::cast_possible_wrap)]
    pub fn update_score(&self, state: &mut CS::State, idx: CorpusId) -> Result<(), Error> {
        // Create a new top rated meta if not existing
        if state.metadata_map().get::<TopRatedsMetadata>().is_none() {
            state.add_metadata(TopRatedsMetadata::new());
        }

        let mut new_favoreds = vec![];
        {
            // 获取第idx个testcase
            let mut entry = state.corpus().get(idx)?.borrow_mut();
            // 计算第idx个testcase的分数
            let factor = F::compute(state, &mut *entry)?;
            // 获取第idx个testcase的metadata
            let meta = entry.metadata_map_mut().get_mut::<M>().ok_or_else(|| {
                Error::key_not_found(format!(
                    "Metadata needed for MinimizerScheduler not found in testcase #{idx}"
                ))
            })?;

            let top_rateds = state.metadata_map().get::<TopRatedsMetadata>().unwrap();
            for elem in meta.as_slice() {
                if let Some(old_idx) = top_rateds.map.get(elem) {
                    if *old_idx == idx {
                        new_favoreds.push(*elem); // always retain current; we'll drop it later otherwise
                        continue;
                    }
                    // 获取old测试用例
                    let mut old = state.corpus().get(*old_idx)?.borrow_mut();
                    // 如果old的分数小于当前的分数，则删除old
                    if factor > F::compute(state, &mut *old)? {
                        continue;
                    }

                    let must_remove = {
                        let old_meta = old.metadata_map_mut().get_mut::<M>().ok_or_else(|| {
                            Error::key_not_found(format!(
                                "{} needed for MinimizerScheduler not found in testcase #{old_idx}",
                                type_name::<M>()
                            ))
                        })?;
                        // 减少引用计数
                        *old_meta.refcnt_mut() -= 1;
                        // 当引用次数为0时，删除old的metadata
                        old_meta.refcnt() <= 0
                    };

                    if must_remove {
                        drop(old.metadata_map_mut().remove::<M>());
                    }
                }
                // 向new_favoreds中添加*elem
                new_favoreds.push(*elem);
            }

            *meta.refcnt_mut() = new_favoreds.len() as isize;
        }

        if new_favoreds.is_empty() {
            drop(
                state
                    .corpus()
                    .get(idx)?
                    .borrow_mut()
                    .metadata_map_mut()
                    .remove::<M>(),
            );
            return Ok(());
        }
        // 向state中添加insert(elem, idx)
        for elem in new_favoreds {
            state
                .metadata_map_mut()
                .get_mut::<TopRatedsMetadata>()
                .unwrap()
                .map
                .insert(elem, idx);
        }
        Ok(())
    }
}
```

cull 函数主要是精简测试用例

```rust
impl<CS, F, M> MinimizerScheduler<CS, F, M>
where
    CS: Scheduler,
    F: TestcaseScore<CS::State>,
    M: AsSlice<Entry = usize> + SerdeAny + HasRefCnt,
    CS::State: HasCorpus + HasMetadata + HasRand,
{
    /// Cull the `Corpus` using the `MinimizerScheduler`
    #[allow(clippy::unused_self)]
    pub fn cull(&self, state: &CS::State) -> Result<(), Error> {
        let Some(top_rated) = state.metadata_map().get::<TopRatedsMetadata>() else {
            return Ok(());
        };

        let mut acc = HashSet::new();
        // 遍历top_rated
        for (key, idx) in &top_rated.map {
            // 如果acc中不包含key
            if !acc.contains(key) {
                // 获取第idx个testcase
                let mut entry = state.corpus().get(*idx)?.borrow_mut();
                // 获取第idx个testcase的metadata
                let meta = entry.metadata_map().get::<M>().ok_or_else(|| {
                    Error::key_not_found(format!(
                        "{} needed for MinimizerScheduler not found in testcase #{idx}",
                        type_name::<M>()
                    ))
                })?;
                // 将meta中的元素添加到acc中
                for elem in meta.as_slice() {
                    acc.insert(*elem);
                }
                // 将entry标记为favored
                entry.add_metadata(IsFavoredMetadata {});
            }
        }

        Ok(())
    }
}
```
运行示例图

![](https://raw.githubusercontent.com/mark0-cn/blog_img/master/img/202308101953077.png)

### CoverageAccountingScheduler

libafl::schedulers::accounting::CoverageAccountingScheduler

使用覆盖率计数的最小化调度器

```rust
/// A minimizer scheduler using coverage accounting
#[derive(Debug)]
pub struct CoverageAccountingScheduler<'a, CS>
where
    CS: UsesState,
    CS::State: Debug,
{
    accounting_map: &'a [u32],
    // 有几率跳过非favored的测试用例
    skip_non_favored_prob: u64,
    // 其实底层是MinimizerScheduler
    inner: MinimizerScheduler<
        CS,
        // 用于计算测试用例的分数，size*time
        LenTimeMulTestcaseScore<<CS as UsesState>::State>,
        MapIndexesMetadata,
    >,
}

impl<'a, CS> Scheduler for CoverageAccountingScheduler<'a, CS>
where
    CS: Scheduler,
    CS::State: HasCorpus + HasMetadata + HasRand + Debug,
    <CS::State as UsesInput>::Input: HasLen,
{
    fn next(&mut self, state: &mut Self::State) -> Result<CorpusId, Error> {
        // 如果测试用例的覆盖率发生了变化
        if state
            .metadata_map()
            .get::<TopAccountingMetadata>()
            .map_or(false, |x| x.changed)
        {
            // 将测试用例调用次数为0的添加为favored
            self.accounting_cull(state)?;
        } else {
            // 精简测试用例
            self.inner.cull(state)?;
        }
        let mut idx = self.inner.base_mut().next(state)?;
        // 返回favored的idx
        while {
            let has = !state
                .corpus()
                .get(idx)?
                .borrow()
                .has_metadata::<IsFavoredMetadata>();
            has
        } && state.rand_mut().below(100) < self.skip_non_favored_prob
        {
            // 有几率跳过非favored的测试用例
            idx = self.inner.base_mut().next(state)?;
        }

        // Don't add corpus.curret(). The inner scheduler will take care of it

        Ok(idx)
    }
}
```

### WeightedScheduler

libafl::schedulers::weighted::WeightedScheduler

一个使用功率调度和加权队列项选择算法的语料库调度器。

一种使用 power schedules with weighted queue 的调度器

```rust
impl<F, O, S> Scheduler for WeightedScheduler<F, O, S>
where
    F: TestcaseScore<S>,
    O: MapObserver,
    S: HasCorpus + HasMetadata + HasRand + HasTestcase,
{
    #[allow(clippy::similar_names, clippy::cast_precision_loss)]
    fn next(&mut self, state: &mut S) -> Result<CorpusId, Error> {
        let corpus_counts = state.corpus().count();
        if corpus_counts == 0 {
            Err(Error::empty(String::from("No entries in corpus")))
        } else {
            // 随机选择一个测试用例
            let s = random_corpus_id!(state.corpus(), state.rand_mut());

            // Choose a random value between 0.000000000 and 1.000000000
            let probability = state.rand_mut().between(0, 1000000000) as f64 / 1000000000_f64;

            let wsmeta = state.metadata_mut::<WeightedScheduleMetadata>()?;

            let current_cycles = wsmeta.runs_in_current_cycle();

            // TODO deal with corpus_counts decreasing due to removals
            // 记录当前周期的执行次数
            if current_cycles >= corpus_counts {
                wsmeta.set_runs_current_cycle(0);
            } else {
                wsmeta.set_runs_current_cycle(current_cycles + 1);
            }
            // 如果随机数小于权重，则选择s，否则选择alias_table中的值
            let idx = if probability < *wsmeta.alias_probability().get(&s).unwrap() {
                s
            } else {
                *wsmeta.alias_table().get(&s).unwrap()
            };

            // Update depth
            if current_cycles > corpus_counts {
                let psmeta = state.metadata_mut::<SchedulerMetadata>()?;
                // psmeta.queue_cycles += 1;
                psmeta.set_queue_cycles(psmeta.queue_cycles() + 1);
            }

            self.set_current_scheduled(state, Some(idx))?;
            Ok(idx)
        }
    }
}
```

### ProbabilitySamplingScheduler

libafl::schedulers::probabilistic_sampling::ProbabilitySamplingScheduler


蓄水池抽样(Reservoir Sampling)调度器，用于随机选择测试用例

```rust
impl<F, S> Scheduler for ProbabilitySamplingScheduler<F, S>
where
    F: TestcaseScore<S>,
    S: HasCorpus + HasMetadata + HasRand + HasTestcase,
{
    /// Gets the next entry
    #[allow(clippy::cast_precision_loss)]
    fn next(&mut self, state: &mut Self::State) -> Result<CorpusId, Error> {
        if state.corpus().count() == 0 {
            Err(Error::empty(String::from("No entries in corpus")))
        } else {
            // 随机数
            let rand_prob: f64 = (state.rand_mut().below(100) as f64) / 100.0;
            let meta = state.metadata_map().get::<ProbabilityMetadata>().unwrap();
            // 阈值
            let threshold = meta.total_probability * rand_prob;
            let mut k: f64 = 0.0;
            let mut ret = *meta.map.keys().last().unwrap();
            for (idx, prob) in meta.map.iter() {
                k += prob;
                // 大于阈值就返回idx
                if k >= threshold {
                    ret = *idx;
                    break;
                }
            }
            self.set_current_scheduled(state, Some(ret))?;
            Ok(ret)
        }
    }
}
```

### EcoScheduler

libafl::schedulers::ecofuzz::EcoScheduler

[EcoFuzz](https://www.usenix.org/conference/usenixsecurity20/presentation/yue)实现的一种调度算法

TODO: 以后有时间再看

```rust
impl<O, S> Scheduler for EcoScheduler<O, S>
where
    S: HasCorpus + HasMetadata + HasRand + HasExecutions + HasTestcase,
    O: MapObserver,
{
    fn next(&mut self, state: &mut S) -> Result<CorpusId, Error> {
        if let Some(id) = *state.corpus().current() {
            Self::handle_previous(id, state)?;
        } else {
            Self::first_iteration(state)?;
        }

        let id = Self::schedule(state)?;
        self.set_current_scheduled(state, Some(id))?;

        let count = state.corpus().count();
        let executions = *state.executions();
        let last_mutation_num = state
            .testcase(id)?
            .metadata::<EcoTestcaseMetadata>()?
            .mutation_num;

        let meta = state.metadata_mut::<EcoMetadata>()?;
        meta.last_corpus_count = count;
        meta.last_mutation_num = last_mutation_num;
        // TODO in theory it should be assigned at the beginning of the mutational stage
        // we must not count executions done in other stages
        meta.last_executions = executions;

        // println!("scheduling {id}");

        Ok(id)
    }
}
```

### PowerQueueScheduler

libafl::schedulers::powersched::PowerQueueScheduler

A corpus scheduler using power schedules

```rust
impl<O, S> Scheduler for PowerQueueScheduler<O, S>
where
    S: HasCorpus + HasMetadata + HasTestcase,
    O: MapObserver,
{
    fn next(&mut self, state: &mut Self::State) -> Result<CorpusId, Error> {
        if state.corpus().count() == 0 {
            Err(Error::empty(String::from("No entries in corpus")))
        } else {
            let id = match state.corpus().current() {
                Some(cur) => {
                    if let Some(next) = state.corpus().next(*cur) {
                        next
                    } else {
                        let psmeta = state.metadata_mut::<SchedulerMetadata>()?;
                        // psmeta.queue_cycles += 1;
                        // 记录执行完一圈，开始下一圈
                        psmeta.set_queue_cycles(psmeta.queue_cycles() + 1);
                        state.corpus().first().unwrap()
                    }
                }
                None => state.corpus().first().unwrap(),
            };
            self.set_current_scheduled(state, Some(id))?;

            Ok(id)
        }
    }
}
```

### QueueScheduler

libafl::schedulers::queue::QueueScheduler

队列调度器，用于按顺序选择测试用例

```rust
impl<S> Scheduler for QueueScheduler<S>
where
    S: HasCorpus + HasTestcase,
{
    /// Gets the next entry in the queue
    fn next(&mut self, state: &mut Self::State) -> Result<CorpusId, Error> {
        if state.corpus().count() == 0 {
            Err(Error::empty("No entries in corpus".to_owned()))
        } else {
            // 按照顺序选择测试用例，到最后一个时，返回第一个
            let id = state
                .corpus()
                .current()
                .map(|id| state.corpus().next(id))
                .flatten()
                .unwrap_or_else(|| state.corpus().first().unwrap());
            self.set_current_scheduled(state, Some(id))?;
            Ok(id)
        }
    }
}
```

### RandScheduler

libafl::schedulers::RandScheduler

随机调度器，用于随机选择测试用例

```rust
impl<S> Scheduler for RandScheduler<S>
where
    S: HasCorpus + HasRand + HasTestcase,
{
    /// Gets the next entry at random
    fn next(&mut self, state: &mut Self::State) -> Result<CorpusId, Error> {
        if state.corpus().count() == 0 {
            Err(Error::empty("No entries in corpus".to_owned()))
        } else {
            let id = random_corpus_id!(state.corpus(), state.rand_mut());
            self.set_current_scheduled(state, Some(id))?;
            Ok(id)
        }
    }
}
```

### TuneableScheduler

libafl::schedulers::tuneable::TuneableScheduler

以类似队列的方式遍历语料库，通过特定的 `set_next` 方法，我们可以手动选择下一个语料库条目。

```rust
impl<S> Scheduler for TuneableScheduler<S>
where
    S: HasCorpus + HasMetadata + HasTestcase,
{
    /// Gets the next entry in the queue
    fn next(&mut self, state: &mut Self::State) -> Result<CorpusId, Error> {
        if state.corpus().count() == 0 {
            return Err(Error::empty("No entries in corpus".to_owned()));
        }
        let id = if let Some(next) = Self::get_next(state) {
            // next was set
            next
        } else if let Some(next) = state.corpus().next(Self::get_current(state)) {
            next
        } else {
            state.corpus().first().unwrap()
        };
        self.set_current_scheduled(state, Some(id))?;
        Ok(id)
    }
}
```

# feedback

```rust
pub trait Feedback<S>: Named + Debug
where
    S: UsesInput + HasClientPerfMonitor,
{
    // Required method
    fn is_interesting<EM, OT>(
        &mut self,
        state: &mut S,
        manager: &mut EM,
        input: &S::Input,
        observers: &OT,
        exit_kind: &ExitKind
    ) -> Result<bool, Error>
       where EM: EventFirer<State = S>,
             OT: ObserversTuple<S>;

    // Provided methods
    fn init_state(&mut self, _state: &mut S) -> Result<(), Error> { ... }
    fn append_metadata<OT>(
        &mut self,
        state: &mut S,
        observers: &OT,
        testcase: &mut Testcase<S::Input>
    ) -> Result<(), Error>
       where OT: ObserversTuple<S> { ... }
    fn discard_metadata(
        &mut self,
        _state: &mut S,
        _input: &S::Input
    ) -> Result<(), Error> { ... }
}
```

## 常见的feedback

### CombinedFeedback

libafl::feedbacks::CombinedFeedback

feedback的组合器，可以将多个feedback组合在一起，通过逻辑关系判断是否有趣

```rust
impl<A, B, FL, S> Feedback<S> for CombinedFeedback<A, B, FL, S>
where
    A: Feedback<S>,
    B: Feedback<S>,
    FL: FeedbackLogic<A, B, S>,
    S: UsesInput + HasClientPerfMonitor + Debug,
{
    #[allow(clippy::wrong_self_convention)]
    fn is_interesting<EM, OT>(
        &mut self,
        state: &mut S,
        manager: &mut EM,
        input: &S::Input,
        observers: &OT,
        exit_kind: &ExitKind,
    ) -> Result<bool, Error>
    where
        EM: EventFirer<State = S>,
        OT: ObserversTuple<S>,
    {
        // 通过逻辑关系判断是否有趣 or and xor
        FL::is_pair_interesting(
            &mut self.first,
            &mut self.second,
            state,
            manager,
            input,
            observers,
            exit_kind,
        )
    }
}
```

### NotFeedback

libafl::feedbacks::NotFeedback

对反馈结果取反

``` rust
impl<A, S> Feedback<S> for NotFeedback<A, S>
where
    A: Feedback<S>,
    S: UsesInput + HasClientPerfMonitor,
{
    #[allow(clippy::wrong_self_convention)]
    fn is_interesting<EM, OT>(
        &mut self,
        state: &mut S,
        manager: &mut EM,
        input: &S::Input,
        observers: &OT,
        exit_kind: &ExitKind,
    ) -> Result<bool, Error>
    where
        EM: EventFirer<State = S>,
        OT: ObserversTuple<S>,
    {
        Ok(!self
            .first
            .is_interesting(state, manager, input, observers, exit_kind)?)
    }
}
```

### DiffFeedback

libafl::feedbacks::differential::DiffFeedback

`DiffFeedback` 使用给定的比较函数来比较两个观察者的内容。

```rust
impl<F, I, O1, O2, S> Feedback<S> for DiffFeedback<F, I, O1, O2, S>
where
    F: FnMut(&O1, &O2) -> DiffResult,
    I: Input,
    S: HasMetadata + HasClientPerfMonitor + State<Input = I>,
    O1: Observer<S> + PartialEq<O2>,
    O2: Observer<S>,
{
    #[allow(clippy::wrong_self_convention)]
    fn is_interesting<EM, OT>(
        &mut self,
        _state: &mut S,
        _manager: &mut EM,
        _input: &I,
        observers: &OT,
        _exit_kind: &ExitKind,
    ) -> Result<bool, Error>
    where
        EM: EventFirer<State = S>,
        OT: ObserversTuple<S> + MatchName,
    {
        fn err(name: &str) -> Error {
            Error::illegal_argument(format!("DiffFeedback: observer {name} not found"))
        }
        let o1: &O1 = observers
            // Match for a name and return the borrowed value
            .match_name(&self.o1_name)
            .ok_or_else(|| err(&self.o1_name))?;
        let o2: &O2 = observers
            .match_name(&self.o2_name)
            .ok_or_else(|| err(&self.o2_name))?;
        // The function used to compare the two observers
        Ok((self.compare_fn)(o1, o2) == DiffResult::Diff)
    }
}
```

### MapEqualityFeedback

libafl::stages::tmin::MapEqualityFeedback

一个反馈机制，用于检查当前观察到的映射的哈希值是否与提供的原始哈希值相等。

```rust
impl<M, S> Feedback<S> for MapEqualityFeedback<M, S>
where
    M: MapObserver + Debug,
    S: UsesInput + HasClientPerfMonitor + Debug,
{
    fn is_interesting<EM, OT>(
        &mut self,
        _state: &mut S,
        _manager: &mut EM,
        _input: &S::Input,
        observers: &OT,
        _exit_kind: &ExitKind,
    ) -> Result<bool, Error>
    where
        EM: EventFirer<State = S>,
        OT: ObserversTuple<S>,
    {
        let obs = observers
            .match_name::<M>(self.observer_name())
            .expect("Should have been provided valid observer name.");
        Ok(obs.hash() == self.orig_hash)
    }
}
```

### MapFeedback

libafl::feedbacks::map::MapFeedback

最常见的类似AFL的反馈类型

```rust
impl<N, O, R, S, T> Feedback<S> for MapFeedback<N, O, R, S, T>
where
    N: IsNovel<T> + Debug,
    O: MapObserver<Entry = T> + for<'it> AsIter<'it, Item = T>,
    R: Reducer<T> + Debug,
    S: UsesInput + HasClientPerfMonitor + HasNamedMetadata + Debug,
    T: Default + Copy + Serialize + for<'de> Deserialize<'de> + PartialEq + Debug + 'static,
{
    #[rustversion::not(nightly)]
    fn is_interesting<EM, OT>(
        &mut self,
        state: &mut S,
        manager: &mut EM,
        input: &<S as UsesInput>::Input,
        observers: &OT,
        exit_kind: &ExitKind,
    ) -> Result<bool, Error>
    where
        EM: EventFirer<State = S>,
        OT: ObserversTuple<S>,
    {
        self.is_interesting_default(state, manager, input, observers, exit_kind)
    }
}

impl<N, O, R, S, T> MapFeedback<N, O, R, S, T>
where
    T: PartialEq + Default + Copy + 'static + Serialize + DeserializeOwned + Debug,
    R: Reducer<T>,
    O: MapObserver<Entry = T>,
    for<'it> O: AsIter<'it, Item = T>,
    N: IsNovel<T>,
    S: UsesInput + HasNamedMetadata + HasClientPerfMonitor + Debug,
{
    #[allow(clippy::wrong_self_convention)]
    #[allow(clippy::needless_range_loop)]
    #[allow(clippy::trivially_copy_pass_by_ref)]
    fn is_interesting_default<EM, OT>(
        &mut self,
        state: &mut S,
        manager: &mut EM,
        _input: &S::Input,
        observers: &OT,
        _exit_kind: &ExitKind,
    ) -> Result<bool, Error>
    where
        EM: EventFirer<State = S>,
        OT: ObserversTuple<S>,
    {
        let mut interesting = false;
        // TODO Replace with match_name_type when stable
        let observer = observers.match_name::<O>(&self.observer_name).unwrap();

        let map_state = state
            .named_metadata_map_mut()
            .get_mut::<MapFeedbackMetadata<T>>(&self.name)
            .unwrap();
        let len = observer.len();
        if map_state.history_map.len() < len {
            map_state.history_map.resize(len, observer.initial());
        }

        let history_map = map_state.history_map.as_slice();

        let initial = observer.initial();

        if let Some(novelties) = self.novelties.as_mut() {
            novelties.clear();
            for (i, item) in observer
                .as_iter()
                .copied()
                .enumerate()
                .filter(|(_, item)| *item != initial)
            {
                let existing = unsafe { *history_map.get_unchecked(i) };
                let reduced = R::reduce(existing, item);
                if N::is_novel(existing, reduced) {
                    interesting = true;
                    novelties.push(i);
                }
            }
        } else {
            for (i, item) in observer
                .as_iter()
                .copied()
                .enumerate()
                .filter(|(_, item)| *item != initial)
            {
                let existing = unsafe { *history_map.get_unchecked(i) };
                // 根据reducer的定义，将item与existing进行比较
                let reduced = R::reduce(existing, item);
                // 判断是否是感兴趣的
                if N::is_novel(existing, reduced) {
                    interesting = true;
                    break;
                }
            }
        }

        if interesting || self.always_track {
            let len = history_map.len();
            let filled = history_map.iter().filter(|&&i| i != initial).count();
            // opt: if not tracking optimisations, we technically don't show the *current* history
            // map but the *last* history map; this is better than walking over and allocating
            // unnecessarily
            manager.fire(
                state,
                Event::UpdateUserStats {
                    name: self.stats_name.to_string(),
                    value: UserStats::Ratio(
                        self.novelties
                            .as_ref()
                            .map_or(filled, |novelties| filled + novelties.len())
                            as u64,
                        len as u64,
                    ),
                    phantom: PhantomData,
                },
            )?;
        }

        Ok(interesting)
    }
}
```

主要作为`MaxMapFeedback`使用

```rust
pub type MaxMapFeedback<O, S, T> = MapFeedback<DifferentIsNovel, O, MaxReducer, S, T>;
```

### ReachabilityFeedback

libafl::feedbacks::map::ReachabilityFeedback

A ReachabilityFeedback reports if a target has been reached.

```rust
impl<O, S> Feedback<S> for ReachabilityFeedback<O, S>
where
    S: UsesInput + Debug + HasClientPerfMonitor,
    O: MapObserver<Entry = usize>,
    for<'it> O: AsIter<'it, Item = usize>,
{
    #[allow(clippy::wrong_self_convention)]
    fn is_interesting<EM, OT>(
        &mut self,
        _state: &mut S,
        _manager: &mut EM,
        _input: &S::Input,
        observers: &OT,
        _exit_kind: &ExitKind,
    ) -> Result<bool, Error>
    where
        EM: EventFirer<State = S>,
        OT: ObserversTuple<S>,
    {
        // TODO Replace with match_name_type when stable
        let observer = observers.match_name::<O>(&self.name).unwrap();
        let mut hit_target: bool = false;
        //check if we've hit any targets.
        for (i, &elem) in observer.as_iter().enumerate() {
            if elem > 0 {
                self.target_idx.push(i);
                hit_target = true;
            }
        }
        if hit_target {
            Ok(true)
        } else {
            Ok(false)
        }
    }
}
```

### NewHashFeedback

libafl::feedbacks::new_hash_feedback::NewHashFeedback

NewHashFeedback维护一个 stacktraces 的哈希集，并且认为未见过的堆栈跟踪是有趣的。

```rust
impl<O, S> Feedback<S> for NewHashFeedback<O, S>
where
    O: ObserverWithHashField + Named + Debug,
    S: UsesInput + Debug + HasNamedMetadata + HasClientPerfMonitor,
{
    #[allow(clippy::wrong_self_convention)]
    fn is_interesting<EM, OT>(
        &mut self,
        state: &mut S,
        _manager: &mut EM,
        _input: &<S as UsesInput>::Input,
        observers: &OT,
        _exit_kind: &ExitKind,
    ) -> Result<bool, Error>
    where
        EM: EventFirer<State = S>,
        OT: ObserversTuple<S>,
    {
        let observer = observers
            .match_name::<O>(&self.observer_name)
            .expect("A NewHashFeedback needs a BacktraceObserver");

        let backtrace_state = state
            .named_metadata_map_mut()
            .get_mut::<NewHashFeedbackMetadata>(&self.name)
            .unwrap();

        match observer.hash() {
            Some(hash) => {
                let res = backtrace_state
                    .update_hash_set(hash)
                    .expect("Failed to update the hash state");
                Ok(res)
            }
            None => {
                // We get here if the hash was not updated, i.e the first run or if no crash happens
                Ok(false)
            }
        }
    }
}
```

### ConstFeedback

libafl::feedbacks::ConstFeedback

ConstFeedback总是报告相同的值。它可以通过组合来启用或禁用反馈结果。

```rust
impl<S> Feedback<S> for ConstFeedback
where
    S: UsesInput + HasClientPerfMonitor,
{
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn is_interesting<EM, OT>(
        &mut self,
        _state: &mut S,
        _manager: &mut EM,
        _input: &S::Input,
        _observers: &OT,
        _exit_kind: &ExitKind,
    ) -> Result<bool, Error>
    where
        EM: EventFirer<State = S>,
        OT: ObserversTuple<S>,
    {
        Ok(match self {
            ConstFeedback::True => true,
            ConstFeedback::False => false,
        })
    }
}
```

### ConcolicFeedback

libafl::feedbacks::concolic::ConcolicFeedback

共轭反馈。它用于向测试用例附加共轭跟踪元数据。此反馈应与其他反馈结合使用，因为该反馈始终认为测试用例不是有趣的。需要共轭观察器（Concolic Observer）来观察共轭跟踪。

```rust
impl<S> Feedback<S> for ConcolicFeedback<S>
where
    S: UsesInput + Debug + HasClientPerfMonitor,
{
    #[allow(clippy::wrong_self_convention)]
    fn is_interesting<EM, OT>(
        &mut self,
        _state: &mut S,
        _manager: &mut EM,
        _input: &<S as UsesInput>::Input,
        _observers: &OT,
        _exit_kind: &ExitKind,
    ) -> Result<bool, Error>
    where
        EM: EventFirer<State = S>,
        OT: ObserversTuple<S>,
    {
        Ok(false)
    }
}
```

### CrashFeedback

libafl::feedbacks::CrashFeedback

```rust
impl<S> Feedback<S> for CrashFeedback
where
    S: UsesInput + HasClientPerfMonitor,
{
    #[allow(clippy::wrong_self_convention)]
    fn is_interesting<EM, OT>(
        &mut self,
        _state: &mut S,
        _manager: &mut EM,
        _input: &S::Input,
        _observers: &OT,
        exit_kind: &ExitKind,
    ) -> Result<bool, Error>
    where
        EM: EventFirer<State = S>,
        OT: ObserversTuple<S>,
    {
        if let ExitKind::Crash = exit_kind {
            Ok(true)
        } else {
            Ok(false)
        }
    }
}
```

### TimeFeedback

libafl::feedbacks::TimeFeedback

无操作（Nop）反馈，它在新的测试用例中注释了执行时间。如果任何情况下此反馈的测试用例都不是有趣的（与 OR 运算符一起使用）。它决定了运行的给定 TimeObserver 值是否是有趣的。

```rust
impl<S> Feedback<S> for TimeFeedback
where
    S: UsesInput + HasClientPerfMonitor,
{
    #[allow(clippy::wrong_self_convention)]
    fn is_interesting<EM, OT>(
        &mut self,
        _state: &mut S,
        _manager: &mut EM,
        _input: &S::Input,
        _observers: &OT,
        _exit_kind: &ExitKind,
    ) -> Result<bool, Error>
    where
        EM: EventFirer<State = S>,
        OT: ObserversTuple<S>,
    {
        // TODO Replace with match_name_type when stable
        Ok(false)
    }
}
```

### TimeoutFeedback

libafl::feedbacks::TimeoutFeedback

```rust
impl<S> Feedback<S> for TimeoutFeedback
where
    S: UsesInput + HasClientPerfMonitor,
{
    #[allow(clippy::wrong_self_convention)]
    fn is_interesting<EM, OT>(
        &mut self,
        _state: &mut S,
        _manager: &mut EM,
        _input: &S::Input,
        _observers: &OT,
        exit_kind: &ExitKind,
    ) -> Result<bool, Error>
    where
        EM: EventFirer<State = S>,
        OT: ObserversTuple<S>,
    {
        if let ExitKind::Timeout = exit_kind {
            Ok(true)
        } else {
            Ok(false)
        }
    }
}
```

### ListFeedback

libafl::feedbacks::ListFeedback

如果 ListObserver 中的列表不为空，则将测试用例视为有趣。

```rust
impl<S, T> Feedback<S> for ListFeedback<T>
where
    S: UsesInput + HasClientPerfMonitor,
    T: Debug + Serialize + serde::de::DeserializeOwned,
{
    #[allow(clippy::wrong_self_convention)]
    fn is_interesting<EM, OT>(
        &mut self,
        _state: &mut S,
        _manager: &mut EM,
        _input: &S::Input,
        observers: &OT,
        _exit_kind: &ExitKind,
    ) -> Result<bool, Error>
    where
        EM: EventFirer<State = S>,
        OT: ObserversTuple<S>,
    {
        // TODO Replace with match_name_type when stable
        let observer = observers
            .match_name::<ListObserver<T>>(self.name())
            .unwrap();
        // TODO register the list content in a testcase metadata
        Ok(!observer.list().is_empty())
    }
}
```

# fuzzer

```rust
pub trait Fuzzer<E, EM, ST>: Sized + UsesState
where
    Self::State: HasClientPerfMonitor + HasMetadata + HasExecutions,
    E: UsesState<State = Self::State>,
    EM: ProgressReporter<State = Self::State>,
    ST: StagesTuple<E, EM, Self::State, Self>,
{
    // Required method
    fn fuzz_one(
        &mut self,
        stages: &mut ST,
        executor: &mut E,
        state: &mut EM::State,
        manager: &mut EM
    ) -> Result<CorpusId, Error>;

    // Provided methods
    fn fuzz_loop(
        &mut self,
        stages: &mut ST,
        executor: &mut E,
        state: &mut EM::State,
        manager: &mut EM
    ) -> Result<CorpusId, Error> { ... }
    fn fuzz_loop_for(
        &mut self,
        stages: &mut ST,
        executor: &mut E,
        state: &mut EM::State,
        manager: &mut EM,
        iters: u64
    ) -> Result<CorpusId, Error> { ... }
}
```

## 常见的fuzzer

目前来说，fuzzer只有一种实现，即StdFuzzer

### StdFuzzer

libafl::fuzzer::StdFuzzer

```rust
pub struct StdFuzzer<CS, F, OF, OT>
where
    CS: Scheduler,
    F: Feedback<CS::State>,
    OF: Feedback<CS::State>,
    CS::State: HasClientPerfMonitor + HasCorpus,
{ /* private fields */ }
```

以`fuzz_loop`函数为例

```rust
fn fuzz_loop(
    &mut self,
    stages: &mut ST,
    executor: &mut E,
    state: &mut EM::State,
    manager: &mut EM,
) -> Result<CorpusId, Error> {
    let mut last = current_time();
    let monitor_timeout = STATS_TIMEOUT_DEFAULT;
    loop {
        // 底层调用fuzz_one实现
        self.fuzz_one(stages, executor, state, manager)?;
        // ProgressReporter向broker报告进度
        last = manager.maybe_report_progress(state, last, monitor_timeout)?;
    }
}
```

`fuzz_one`函数

进行一次模糊迭代。返回最后一个模糊过的语料库项的索引。（注意：一个迭代代表每个阶段的完整运行。因此，它并不意味着执行了一次目标的测试用例，因为每个阶段可能会运行多次目标的测试用例。）

```rust
impl<CS, E, EM, F, OF, OT, ST> Fuzzer<E, EM, ST> for StdFuzzer<CS, F, OF, OT>
where
    CS: Scheduler,
    E: UsesState<State = CS::State>,
    EM: ProgressReporter + EventProcessor<E, Self, State = CS::State>,
    F: Feedback<CS::State>,
    OF: Feedback<CS::State>,
    CS::State: HasClientPerfMonitor + HasExecutions + HasMetadata + HasCorpus + HasTestcase,
    ST: StagesTuple<E, EM, CS::State, Self>,
{
    fn fuzz_one(
        &mut self,
        stages: &mut ST,
        executor: &mut E,
        state: &mut CS::State,
        manager: &mut EM,
    ) -> Result<CorpusId, Error> {
        // Init timer for scheduler
        #[cfg(feature = "introspection")]
        state.introspection_monitor_mut().start_timer();

        // Get the next index from the scheduler
        let idx = self.scheduler.next(state)?;

        // Mark the elapsed time for the scheduler
        #[cfg(feature = "introspection")]
        state.introspection_monitor_mut().mark_scheduler_time();

        // Mark the elapsed time for the scheduler
        #[cfg(feature = "introspection")]
        state.introspection_monitor_mut().reset_stage_index();

        // Execute all stages
        stages.perform_all(self, executor, state, manager, idx)?;

        // Init timer for manager
        #[cfg(feature = "introspection")]
        state.introspection_monitor_mut().start_timer();

        // Execute the manager
        manager.process(self, state, executor)?;

        // Mark the elapsed time for the manager
        #[cfg(feature = "introspection")]
        state.introspection_monitor_mut().mark_manager_time();

        {
            let mut testcase = state.testcase_mut(idx)?;
            let scheduled_count = testcase.scheduled_count();

            // increase scheduled count, this was fuzz_level in afl
            testcase.set_scheduled_count(scheduled_count + 1);
        }

        Ok(idx)
    }
}
```

在忽略掉`#[cfg(feature = "introspection")]`相关代码后，可以发现 `fuzz_one`函数的主要逻辑是：

1. 从scheduler.next 中获取下一个测试用例的id
2. stages.perform_all 执行所有的阶段
3. manager.process 执行manager
4. count + 1

next 函数

```rust
pub trait Scheduler: UsesState
where
    Self::State: HasCorpus,
{
    /// Gets the next entry
    fn next(&mut self, state: &mut Self::State) -> Result<CorpusId, Error>;
}
```

perform_all 函数

```rust
/// A tuple holding all `Stages` used for fuzzing.
pub trait StagesTuple<E, EM, S, Z>
where
    E: UsesState<State = S>,
    EM: UsesState<State = S>,
    Z: UsesState<State = S>,
    S: UsesInput,
{
    /// Performs all `Stages` in this tuple
    fn perform_all(
        &mut self,
        fuzzer: &mut Z,
        executor: &mut E,
        state: &mut S,
        manager: &mut EM,
        corpus_idx: CorpusId,
    ) -> Result<(), Error>;
}
```

process 函数

```rust
pub trait EventProcessor<E, Z>: UsesState {
    // Required method
    fn process(
        &mut self,
        fuzzer: &mut Z,
        state: &mut Self::State,
        executor: &mut E
    ) -> Result<usize, Error>;
}
```
