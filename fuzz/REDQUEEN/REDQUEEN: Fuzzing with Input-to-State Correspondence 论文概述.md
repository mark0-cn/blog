## INPUT-TO-STATE CORRESPONDENCE

在本节中，我们介绍一种基于洞察力的新型模糊测试方法，该方法基于程序具有强大的输入状态对应关系这一观点。

我们观察到，对于大量的程序来说，在执行过程中直接使用输入的值。通过观察这些值，我们可以做出有根据的猜测，以确定替换哪些偏移量（类似于非常轻量级的污点跟踪）和使用哪个值（类似于基于符号执行的方法）。

我们可以利用这种关系来解决诸如magic bytes和（甚至嵌套的）checksums等具有挑战性的模糊测试问题。我们解释了我们的方法的不同构建块，并讨论了它们如何解决我们之前介绍的具有挑战性的模糊测试问题。

### magic bytes

我们首先解决的障碍是magic bytes。这类模糊测试问题的典型示例在清单2中展示，它是我们在清单1中引入的运行示例的一部分摘录。值得注意的是，虽然在示例中我们使用ASCII值以便阅读，但输入状态对应关系同样适用于二进制格式。

![](https://raw.githubusercontent.com/mark0-cn/blog_img/master/img/202308012046936.png)

这些结构对于反馈驱动的模糊测试工具来说很难解决，因为它们很难猜出一个满意的输入；例如，在这种情况下，64位输入MAGICHDR。现有的方法[16]、[23]、[34]、[35]、[38]、[40]通常使用污点跟踪和符号执行，这两种方法都会带来一定的性能开销。

而与这些方法相对应的另一种方法是用户定义的字典[43]，它们代表了关于被测试程序的专业知识。最后，还有一种方法是将多字节比较拆分为多个单字节比较，模糊测试工具能够解决单个字节。

最典型的例子是LAF-INTEL [2]，它在解决多字节比较方面非常高效，但需要源代码级别的访问权限来修改程序。

另一个工具是STEELIX [31]，它不依赖于对源代码的访问。相反，它使用动态二进制插桩将大型比较拆分为较小的比较。

不幸的是，这种方法会带来较大的性能开销。STEELIX的作者报告称，LAF-INTEL每秒执行的次数是STEELIX的7倍以上。


我们提出了以下基于输入状态对应关系的轻量级方法，以完全自动化的方式处理magic bytes：

我们利用程序状态中的值通常直接对应于输入的部分这一事实。每当我们遇到一个新的路径时，我们会挂钩所有的比较指令并执行一次跟踪运行。

如果我们遇到一个具有不同参数的比较，我们会提取出这两个参数，并创建一个自定义的变异 <pattern → repl>，如下所述。不同的步骤在表I中进行了说明。

![](https://raw.githubusercontent.com/mark0-cn/blog_img/master/img/202308012051024.png)

（论文可能写错了🤣，或许应该是 "deeStset" 而不是 "deeStesT"）

1. Tracing：当我们开始对一个新的输入进行模糊测试（在进入KAFL的deterministic阶段之前），我们执行一次单独的运行，在其中挂钩所有的比较指令并提取参数。这包括一些由编译器生成的指令，用于替换普通的比较指令或switch-case结构（通过计算跳转表中的偏移量）。此外，我们还挂钩所有的调用指令，因为函数可能会实现字符串比较和类似功能。有关更多细节，请参阅第四节。

+ 示例1. 考虑"TestSeedInput"作为Listting2中代码的输入。比较指令检查输入的前8个字节（解释为64位无符号值）是否等于字符串"MAGICHDR"的64位无符号解释。由于整数通常以小端格式编码，所以在比较中使用的最终值的ASCII表示分别是"deeStesT"和"RDHCIGAM"。

2. Variations：在运行时，我们不知道在比较之后检查了哪些标志；我们无法区分不同的比较操作，比如"小于"和"等于"。因此，我们对比较的值应用一些变异，比如加一和减一。作为这种启发式方法的副作用，我们经验性地发现这种方法增加了触发偏移一错误的概率。

+ 示例2. 在这种情况下，我们对"RDHCIGAM"分别进行加1和减1操作，得到"RDHCIGAL"和"RDHCIGAN"。


3. 编码：在到达实际比较之前，输入很可能以不同的方式进行了处理。为了处理最常见的输入编码和解码情况，并创建更多的变异候选项，我们对变异应用各种不同的编码。这些编码的示例包括反转零扩展或端序转换。

+ 示例3. 我们对当前的变异"RDHCIGAM"和"RDHCIGAL"应用小端编码，得到"MAGICHDR"、"LAGICHDR"和"NAGICHDR"。

我们观察到，通常只需要几种基本的编码方案。迄今为止，最常见的情况是输入值与状态值之间的一对一映射。在详细方面，我们在实验中使用的编码如下


+ Zero/Sign Extend(n)：将值解释为小端整数，并进行零扩展或符号扩展，剥离前导字节以生成长度为n的模式版本（如果适用）。当没有大小变化时，这种编码也被称为普通编码。

+ Reverse：所有小端编码方案都有对应的大端编码。

+ C-String：将值视为C-String，并删除第一个0字节之后的所有内容。

+ Memory（n）：将值视为类似于memcmp的函数的参数。仅考虑前n ∈ {4, 5, ... , 32}字节。

+ ASCII：将整数值编码为ASCII数字。

在我们手动评估了模糊测试工具产生的覆盖率后，我们相信上述一组编码方案涵盖了实际应用中大部分常见情况。

在极少数情况下，如果这些编码不足够，这组编码方案也可以被视为用户输入，类似于其他模糊测试系统中的字典。在这种情况下，用户可以轻松地提供自己更具体的编码方案。

这一步可以看作是一种轻量级的合成算法变体，用于猜测当前位置的符号状态。实际上，与其他推断输入如何影响状态的方法（如符号执行或程序合成）相比，这种方法有一个主要优势；即非常容易表示复杂的操作，比如将十进制ASCII数字转换为整数。这是因为我们只需要在具体值上执行编码，而不需要用符号值查询SMT求解器。

4. Application：最后，也是最重要的是，我们使用变异的模式 <pattern → repl> 来识别输入中需要用变异 repl 替换的部分。与其他方法（如ANGORA或STEELIX）不同，我们一次性应用整个模式。这有两个优点：它适用于原子比较，无需对目标进行进一步修改/挂钩，并且大大减少了尝试替换的候选位置的数量。

+ 示例4. 输入"TestSeedInput"中只有子字符串"TestSeed"与"MAGICHDR"进行比较。因此，我们只替换这部分内容，得到新的测试用例"MAGICHDRInput"，以及通过解决不等式引入的变种："LAGICHDRInput" 和 "NAGICHDRInput"（以及可能为其他编码方案生成的更多输入）。

5. Colorization：我们发现应用补丁的候选位置的数量有时相当大。 例如，最小的有效ext4文件系统映像为64 KB，主要由长串零字节组成。将单个零值与某个常数进行比较将产生60,000多个可能位置。在我们的评估中，我们发现这些比较相当频繁发生。因此，我们设计了一种有效的方法来增加输入中的随机字节数量。

输入中的更多熵减少了可能位置的空间。使用这个"着色"的输入副本，通常可以大幅减少候选位置的数量，通常是几个数量级。

生成着色版本后，我们只应用在两个输入的相同偏移处找到模式部分的变异。结果是，要应用的剩余变异数量大大减少。在我们的评估中，我们发现通过这种方法引入的变异数量通常比AFL在相同输入上执行的确定性变异数量小两个数量级。

+ 示例5. 假设我们在运行示例中测试输入"ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ"。在变异中，我们会找到 <ZZZZZZZZ → MAGICHDR>。这个变异可以应用在很多（共24个）不同的位置。因此，我们尝试尽可能多地替换字符，而不改变执行路径。在这种情况下，着色版本可以是任意随机的字节串（比如"QYISLKFYDBYYSYWSIBSXEAXOKHNRUCYU"）。相应地，再次运行时，同一个指令将产生变异：<QYISLKFY → MAGICHDR>，这只能应用在第一个位置。因此，在位置0上我们只生成一个候选项。

6. Strings and Memory：除了前面提到的整数比较外，程序通常还会使用函数来比较两个字符串或字节数组的内容。类似地，这些测试对模糊测试工具通常构成了重大挑战。为了克服这样的结构，我们还挂钩所有的函数调用。如果函数至少有两个指针参数，我们提取被指向的前128个字节，并将它们类似于整数进行处理。然而，我们对内存内容使用不同的编码集合，尤其是我们假设只有前n ∈ {4, 5, ... , 32}字节进行比较（类似于memcmp的函数），或者比较直到第一个空字节的所有字节（类似于strcmp系列的函数）。

7. Input Specific Dictionary：最后，我们将包含许多连续非零或非0xff字节的值添加到特定的字典中。以这种方式找到的字符串仅在当前输入的混乱阶段使用。这使我们可以在使用non-trivial的算法（如哈希表查找）的同时，使用传递给函数的值，其内部工作方式类似于比较。在某种程度上，这是一个更强大的版本，类似于从strings tool中提取输出并将其用作模糊测试运行的字典的众所周知的技巧，因为我们包括动态计算的字符串，而不包括在此路径上不相关的字符串。