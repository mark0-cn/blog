## INPUT-TO-STATE CORRESPONDENCE

在本节中，我们介绍一种基于洞察力的新型模糊测试方法，该方法基于程序具有强大的输入状态对应关系这一观点。

我们观察到，对于大量的程序来说，在执行过程中直接使用输入的值。通过观察这些值，我们可以做出有根据的猜测，以确定替换哪些偏移量（类似于非常轻量级的污点跟踪）和使用哪个值（类似于基于符号执行的方法）。

我们可以利用这种关系来解决诸如magic bytes和（甚至嵌套的）checksums等具有挑战性的模糊测试问题。我们解释了我们的方法的不同构建块，并讨论了它们如何解决我们之前介绍的具有挑战性的模糊测试问题。

### magic bytes

我们首先解决的障碍是magic bytes。这类模糊测试问题的典型示例在清单2中展示，它是我们在清单1中引入的运行示例的一部分摘录。值得注意的是，虽然在示例中我们使用ASCII值以便阅读，但输入状态对应关系同样适用于二进制格式。

![](https://raw.githubusercontent.com/mark0-cn/blog_img/master/img/202308012046936.png)

这些结构对于反馈驱动的模糊测试工具来说很难解决，因为它们很难猜出一个满意的输入；例如，在这种情况下，64位输入MAGICHDR。现有的方法[16]、[23]、[34]、[35]、[38]、[40]通常使用污点跟踪和符号执行，这两种方法都会带来一定的性能开销。

而与这些方法相对应的另一种方法是用户定义的字典[43]，它们代表了关于被测试程序的专业知识。最后，还有一种方法是将多字节比较拆分为多个单字节比较，模糊测试工具能够解决单个字节。

最典型的例子是LAF-INTEL [2]，它在解决多字节比较方面非常高效，但需要源代码级别的访问权限来修改程序。

另一个工具是STEELIX [31]，它不依赖于对源代码的访问。相反，它使用动态二进制插桩将大型比较拆分为较小的比较。

不幸的是，这种方法会带来较大的性能开销。STEELIX的作者报告称，LAF-INTEL每秒执行的次数是STEELIX的7倍以上。


我们提出了以下基于输入状态对应关系的轻量级方法，以完全自动化的方式处理magic bytes：

我们利用程序状态中的值通常直接对应于输入的部分这一事实。每当我们遇到一个新的路径时，我们会挂钩所有的比较指令并执行一次跟踪运行。

如果我们遇到一个具有不同参数的比较，我们会提取出这两个参数，并创建一个自定义的变异 <pattern → repl>，如下所述。不同的步骤在表I中进行了说明。

![](https://raw.githubusercontent.com/mark0-cn/blog_img/master/img/202308012051024.png)

（论文可能写错了🤣，或许应该是 "deeStset" 而不是 "deeStesT"）

1. Tracing：当我们开始对一个新的输入进行模糊测试（在进入KAFL的deterministic阶段之前），我们执行一次单独的运行，在其中挂钩所有的比较指令并提取参数。这包括一些由编译器生成的指令，用于替换普通的比较指令或switch-case结构（通过计算跳转表中的偏移量）。此外，我们还挂钩所有的调用指令，因为函数可能会实现字符串比较和类似功能。有关更多细节，请参阅第四节。

+ 示例1. 考虑"TestSeedInput"作为Listting2中代码的输入。比较指令检查输入的前8个字节（解释为64位无符号值）是否等于字符串"MAGICHDR"的64位无符号解释。由于整数通常以小端格式编码，所以在比较中使用的最终值的ASCII表示分别是"deeStesT"和"RDHCIGAM"。

2. Variations：在运行时，我们不知道在比较之后检查了哪些标志；我们无法区分不同的比较操作，比如"小于"和"等于"。因此，我们对比较的值应用一些变异，比如加一和减一。作为这种启发式方法的副作用，我们经验性地发现这种方法增加了触发偏移一错误的概率。

+ 示例2. 在这种情况下，我们对"RDHCIGAM"分别进行加1和减1操作，得到"RDHCIGAL"和"RDHCIGAN"。


3. Encodings：在到达实际比较之前，输入很可能以不同的方式进行了处理。为了处理最常见的输入编码和解码情况，并创建更多的变异候选项，我们对变异应用各种不同的编码。这些编码的示例包括反转零扩展或端序转换。

+ 示例3. 我们对当前的变异"RDHCIGAM"和"RDHCIGAL"应用小端编码，得到"MAGICHDR"、"LAGICHDR"和"NAGICHDR"。

我们观察到，通常只需要几种基本的编码方案。迄今为止，最常见的情况是输入值与状态值之间的一对一映射。在详细方面，我们在实验中使用的编码如下


+ Zero/Sign Extend(n)：将值解释为小端整数，并进行零扩展或符号扩展，剥离前导字节以生成长度为n的模式版本（如果适用）。当没有大小变化时，这种编码也被称为普通编码。

+ Reverse：所有小端编码方案都有对应的大端编码。

+ C-String：将值视为C-String，并删除第一个0字节之后的所有内容。

+ Memory（n）：将值视为类似于memcmp的函数的参数。仅考虑前n ∈ {4, 5, ... , 32}字节。

+ ASCII：将整数值编码为ASCII数字。

在我们手动评估了模糊测试工具产生的覆盖率后，我们相信上述一组编码方案涵盖了实际应用中大部分常见情况。

在极少数情况下，如果这些编码不足够，这组编码方案也可以被视为用户输入，类似于其他模糊测试系统中的字典。在这种情况下，用户可以轻松地提供自己更具体的编码方案。

这一步可以看作是一种轻量级的合成算法变体，用于猜测当前位置的符号状态。实际上，与其他推断输入如何影响状态的方法（如符号执行或程序合成）相比，这种方法有一个主要优势；即非常容易表示复杂的操作，比如将十进制ASCII数字转换为整数。这是因为我们只需要在具体值上执行编码，而不需要用符号值查询SMT求解器。

4. Application：最后，也是最重要的是，我们使用变异的模式 <pattern → repl> 来识别输入中需要用变异 repl 替换的部分。与其他方法（如ANGORA或STEELIX）不同，我们一次性应用整个模式。这有两个优点：它适用于原子比较，无需对目标进行进一步修改/挂钩，并且大大减少了尝试替换的候选位置的数量。

+ 示例4. 输入"TestSeedInput"中只有子字符串"TestSeed"与"MAGICHDR"进行比较。因此，我们只替换这部分内容，得到新的测试用例"MAGICHDRInput"，以及通过解决不等式引入的变种："LAGICHDRInput" 和 "NAGICHDRInput"（以及可能为其他编码方案生成的更多输入）。

5. Colorization：我们发现应用补丁的候选位置的数量有时相当大。 例如，最小的有效ext4文件系统映像为64 KB，主要由长串零字节组成。将单个零值与某个常数进行比较将产生60,000多个可能位置。在我们的评估中，我们发现这些比较相当频繁发生。因此，我们设计了一种有效的方法来增加输入中的随机字节数量。

输入中的更多熵减少了可能位置的空间。使用这个"着色"的输入副本，通常可以大幅减少候选位置的数量，通常是几个数量级。

生成着色版本后，我们只应用在两个输入的相同偏移处找到模式部分的变异。结果是，要应用的剩余变异数量大大减少。在我们的评估中，我们发现通过这种方法引入的变异数量通常比AFL在相同输入上执行的确定性变异数量小两个数量级。

+ 示例5. 假设我们在运行示例中测试输入"ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ"。在变异中，我们会找到 <ZZZZZZZZ → MAGICHDR>。这个变异可以应用在很多（共24个）不同的位置。因此，我们尝试尽可能多地替换字符，而不改变执行路径。在这种情况下，着色版本可以是任意随机的字节串（比如"QYISLKFYDBYYSYWSIBSXEAXOKHNRUCYU"）。相应地，再次运行时，同一个指令将产生变异：<QYISLKFY → MAGICHDR>，这只能应用在第一个位置。因此，在位置0上我们只生成一个候选项。

6. Strings and Memory：除了前面提到的整数比较外，程序通常还会使用函数来比较两个字符串或字节数组的内容。类似地，这些测试对模糊测试工具通常构成了重大挑战。为了克服这样的结构，我们还挂钩所有的函数调用。如果函数至少有两个指针参数，我们提取被指向的前128个字节，并将它们类似于整数进行处理。然而，我们对内存内容使用不同的编码集合，尤其是我们假设只有前n ∈ {4, 5, ... , 32}字节进行比较（类似于memcmp的函数），或者比较直到第一个空字节的所有字节（类似于strcmp系列的函数）。

7. Input Specific Dictionary：最后，我们将包含许多连续非零或非0xff字节的值添加到特定的字典中。以这种方式找到的字符串仅在当前输入的混乱阶段使用。这使我们可以在使用non-trivial的算法（如哈希表查找）的同时，使用传递给函数的值，其内部工作方式类似于比较。在某种程度上，这是一个更强大的版本，类似于从strings tool中提取输出并将其用作模糊测试运行的字典的众所周知的技巧，因为我们包括动态计算的字符串，而不包括在此路径上不相关的字符串。

### Checksums

对于模糊测试工具来说，另一个常见的挑战是高效地模糊超过校验和的部分。这种挑战的典型示例在Listing 3中展示，它是我们在Listing 1中引入的运行示例的一部分摘录。

![](https://raw.githubusercontent.com/mark0-cn/blog_img/master/img/202308022026105.png)

现有的方法，如FLAYER [18]、TAINTSCOPE [40]或T-FUZZ [34]，都依赖于相同的思想：先删除硬性检查，然后再进行修复。TAINTSCOPE和T-FUZZ都会自动检测关键检查，然后在发现有趣的行为后使用符号执行来修复这些检查。

我们提出用基于输入状态对应关系的以下过程来取代TAINTSCOPE和T-FUZZ中使用的污点跟踪和符号执行：

首先，我们识别那些看起来类似于校验和检查的比较（例如，一侧是输入状态对应值，另一侧经常变化）。然后，我们用一个总是评估为true的比较来替换这个检查。一旦在经过修补的程序上进行的模糊测试产生了看似有趣的路径，我们进入验证模式。在这个模式下，我们使用前面描述的技术来修正所有被修补的比较。如果成功，我们继续如之前一样；否则，我们就知道一个比较不在我们的控制范围内，我们会删除该指令的修补，以避免将来执行不必要的验证步骤。


基于输入状态对应关系的思想，我们能够自动推断要修补的指令。此外，我们可以自动修复输入，而无需使用人工干预或复杂的污点跟踪和符号执行。在反馈模糊测试中，我们修复所有新发现的输入（与TAINTSCOPE和T-FUZZ不同）。这确保队列中不会存储错误的阳性结果。作为额外的好处，这允许与其他工具共享队列。接下来，我们重点讨论选择、修补和验证疑似校验和（尤其是哈希和类似哈希计算）的细节。

![](https://raw.githubusercontent.com/mark0-cn/blog_img/master/img/202308022105980.png)

1. Identification：第一步发生在处理魔数时，如第III-A节所述。这会得到一组比较和在所有不同着色版本的输入中进行比较的值。我们使用以下启发式方法来筛选与校验和相关的有趣修补候选的比较指令：

+ 我们能够在所有输入中使用相同的编码找到变异模式的左侧。

+ 两个参数都不是立即值。

+ 在着色阶段，模式发生了变化（这类似于TAINTSCOPE使用的约束：该值取决于许多输入字节）。

这些检查背后的直觉如下：我们观察到一条指令产生了变异 <pattern → repl>。假设 pattern 是输入的一个字段，而 repl 是计算在输入的某个部分上的哈希。

在校验和比较中，左侧应始终是输入的一部分，并且在着色过程中用随机值替换输入的大部分应该会改变哈希值（因此 repl 会改变）。

类似地，如果 pattern 是输入的一个值，而 repl 是计算在输入的某个部分上的哈希，则两个参数都不能是立即值。显然，这是一个过度估计，我们有时会发现不是实际校验和的检查。

因此，这种方法有一个重大缺点：移除的指令可能是相关的边界检查，删除它们可能会引入错误的新覆盖或甚至导致程序后续崩溃。

因此，我们引入了验证阶段来消除潜在的错误阳性，并确定不能修补的比较指令。在模糊测试工具发现新的输入并将其存储到队列之前，我们尝试修复所有被修补的比较指令。如果我们发现了模糊测试工具无法自动修复的修补，我们立即删除该修补。

此外，在输入到达队列之前，我们丢弃该输入。这确保我们不会浪费时间在我们不能轻易修复的修补上，并且不会产生错误的新覆盖：每个输入都与未修改的可执行文件进行验证。

2. Patching：在我们识别了一组疑似的哈希检查后，我们通过patch来替换这些指令，这些补丁具有
相同比较成功的作用。显然，这可能导致不希望的行为：我们可能会意外地删除边界检查或使路径可达，而在没有我们的patch的情况下无法触发这些路径。尽管如此，我们继续使用这个新修补的二进制进行模糊测试，因为我们稍后会解决这些问题。

3. Verification：在对一个输入执行了整个模糊测试阶段之后，我们得到了一个初步结果的队列。由于我们的补丁，这些输入在未修补的目标上可能不会显示预期的行为。在验证阶段，我们尝试通过应用从修补指令中获得的基于输入状态的变异来修复这些无效输入。然后，我们在未修补的真实目标上执行修复后的输入。如果它们仍然触发新的覆盖，那么修复后的输入会被写入真正的队列。否则，我们舍弃这个修补。在以这种方式处理了所有初步输入后，初步队列会被清空以进行下一轮。

## IMPLEMENTATION DETAILS


在下面，我们简要介绍我们的方法的概念验证实现REDQUEEN。我们的REDQUEEN实现基于我们的模糊测试工具KAFL [37]。

### kAFL模糊测试器

KAFL是一个OS无关的、受AFL启发的反馈驱动内核模糊测试器，它使用硬件加速的追踪特性Intel Processor Trace (Intel PT) 来获取覆盖信息，无需对目标进行插装。它建立在修改过的KVM和QEMU版本之上（即KVM-PT和QEMU-PT），以在隔离环境中执行任意的x86操作系统。

这样，模糊测试器可以从虚拟化功能中受益，比如硬件加速的代码执行、快照以及对客户机代码的Intel PT追踪。KVM-PT使得客户机可以使用Intel PT进行追踪，而QEMU-PT则将生成的追踪转换为AFL兼容的位图。为此，QEMU-PT维护了目标的运行时反汇编。这个反汇编是完美的，也就是说，我们反汇编了根据Intel PT追踪执行的每一条指令。我们使用这个反汇编来识别要挂钩或修补的指令。这避免了基于静态反汇编对代码进行修补的问题，静态反汇编可能会误分类一些字节。

QEMU-PT和KVM-PT还提供了自定义的超级调用和对客户机内存的直接访问，以便与目标进行必要的通信和数据传输。模糊测试器逻辑基于AFL模糊测试循环（增加了radamsa [29]阶段），并用Python重新实现。因此，模糊测试逻辑与目标操作系统无关。

我们还修复了Intel PT数据包解码中的一些错误，消除了由于损坏的追踪导致的大量非确定性。总共，我们添加和更改了约1万行代码。

其中很大一部分的更改并不是基于本文提出的技术。这些更改大多数是为了添加对Ring 3模糊测试的支持，为KAFL提供VMI功能，并修复错误。此外，这些数量还包含用于评估和调试目的的大量代码。

### Comparison Hooking

我们依赖于硬件辅助的虚拟机断点来提取输入状态对应关系。每当运行时反汇编器遇到一个有趣的类似比较的指令时，它的地址被存储，以便在下一个REDQUEEN分析阶段放置一个Hook。在REDQUEEN阶段，所有有趣的指令上都会设置断点。当断点被触发时，参数被提取并保存到一个缓冲区中，供模糊测试逻辑稍后使用。为了限制性能影响，断点在被触发一小部分次数后被移除。

注意，我们不仅挂钩cmp指令，还挂钩call指令和减法指令。前者用于识别字符串和内存比较，而减法指令通常由编译器在cmp指令的位置上发出，以实现switch表。为了实现减法，编译器有时会发出带有负偏移的特殊lea或add指令。

如果call指令的前两个参数是有效的指针（根据各种调用约定），我们认为该函数是一个潜在的比较函数，并为每个参数转储前128字节的内存。

### Colorization

在着色化步骤中，我们尝试尽可能多地用随机值替换字节，而不改变执行路径（更准确地说，是AFL位图的哈希）。这增加了输入中的熵，因此减少了可以应用观察到的模式的位置的数量。这可以使用二分搜索方法来实现，如算法1所示，通常会在少数执行次数内收敛（通常在几百次的数量级）。最坏情况下，执行次数将与AFL在每个输入上执行的位翻转数量相当。此外，在我们的实现中，我们将搜索限制在最多1000步。这在文件系统驱动目标上也效果很好，最小输入大小为64 KB。

![](https://raw.githubusercontent.com/mark0-cn/blog_img/master/img/202308022114059.png)

### Instruction Patching

一旦模糊测试逻辑从输入状态对应数据中计算出一组候选哈希比较指令，我们将它们替换为总是返回真的虚假比较指令。在我们的实现中，我们使用指令cmp al, al，因为它是x86指令集架构中最小的比较指令。

原始指令的其余字节用NOP填充。我们使用KVM和QEMU的调试功能，在VM内存中应用这些修补程序。然后使用已修补的VM继续正常的模糊测试过程。

然而，如果修补程序处于活动状态，新发现的路径不会立即添加到队列。有时，即使是良性的C代码和常见的编译器也会产生在指令中间跳转的汇编代码。在我们的情况下，这可以通过Intel Processor Tracing (PT)运行时反汇编来检测。

在其他情况下，可能会使用诸如指令双关[15]甚至纯粹的断点技术来避免引入意外的崩溃。然而，值得注意的是，即使在相对较大的目标程序中，我们也没有观察到任何这样的行为，因为修补的指令数量很少（即在我们的实证评估中通常小于5）。

### Input Validation and Fixing

我们使用算法2来验证和修复初步结果。这个算法反复尝试通过重复应用个体变异来修复所有的比较，并观察结果的输入状态对应关系。

需要注意的是，在修复输入时，存在一些比较的顺序需要保持。通常，如果文件格式的头部包含对整个文件内容的校验和，并且文件中的某些块也受到校验和的保护，就会遇到这种情况。

例如，PNG文件的IDAT块的内容是通过CRC-32校验和保护的。如果内容经过zlib压缩，它又会通过另一个ADLER-32校验和进行保护。在这些情况下，我们必须先修复内部校验和，以便正确计算外部校验和。这些校验和的检查顺序并不明显。

然而，外部校验和先被检查的情况更为常见。因此，我们尝试首先修复最后一个比较，以避免不必要的工作。在我们的实验中，这种简单的方法已经足够了。

然而，通常我们不能假设这种情况。在按照出现顺序的相反顺序执行一系列试验运行以修复所有校验和时，我们观察哪些变异影响了哪些比较指令。通过这样做，我们创建了不同修补指令的依赖图。如果第一次迭代的输入无效，我们使用这个依赖图对修补进行拓扑排序，以获取一个有效的顺序。

这样，我们就可以按照所需的顺序对输入进行另一轮修复。如果最终输入在未修改的可执行文件上没有展现出预期的行为，我们会移除有问题的修补，并且丢弃初步队列中的该输入。

![](https://raw.githubusercontent.com/mark0-cn/blog_img/master/img/202308022122214.png)

在算法2中使用的"get_broken_cmps"例程返回一个列表，其中包含所有当前尚未满足的已修补比较指令，以及正在进行比较的值。"try_fix_value_for_patch"例程尝试应用所有由已修补指令产生的变异，如第III-A节所述。然后，此函数检查是否有任何变异修复了比较。如果找到这样的输入，将其返回。否则，我们得知无法使用我们的技术满足比较指令。修补程序将从用于后续模糊测试运行的修补程序列表中删除。"get_cmps_influenced"例程找到所有由最后修复应用于输入的指令影响其参数的比较指令。这有助于构建比较指令的顺序，在需要时可以在后续步骤中使用。

+ 示例6。考虑我们在Listing 1中展示的运行示例的Bug 2。在我们移除了两个校验和检查之后，fuzzer找到了初步输入"01234567abcdefghRQ"。跟踪得到以下结果：p1 := <01234567 → \xc7\x03\0\0\0\0\0\0> 和 p2 := <abcdefgh → \xa3\0\0\0\0\0\0\0>。如果我们同时应用这两个变异，第二个变异会使第一个变异的和无效。

因此，我们首先尝试修复第二个修补程序（p2），并注意到p1会受到影响。在修复p2后，我们获得输入："01234567\xa3\0\0\0\0\0\0\0RQ"。改变输入的内部校验和也会改变p1的预期值。现在p1的新变异是：<01234567 → \x46\x01\0\0\0\0\0\0>。然后我们应用第一个修补程序p1。这次我们没有干扰任何其他修补程序。最终的输入是："\x46\x01\0\0\0\0\0\0\xa3\0\0\0\0\0\0\0RQ"。
  
由于这个输入满足了所有已修补的约束条件，我们在没有修补的情况下进行了最后一次运行，以确保输入的行为符合预期。这个输入确实触发了Bug 2，并被从初步队列移动到真正的队列中。在这个例子中，我们不需要拓扑排序操作来排序这些检查，因为我们猜到了一个正确的顺序来修复这些修补程序。

### Linux User Space Application Loader for KAFL

我们通过一个Linux Ring 3加载器来扩展KAFL，以便与其他用户空间模糊器进行评估，并展示我们的方法是通用且稳健的。该加载器重新实现了AFL fork服务器。由于我们的目标是二进制文件，我们使用LD PRELOAD将fork服务器功能注入到目标的启动例程中。与模糊测试逻辑的通信是通过由注入的启动例程触发的自定义KAFL超调用来实现的。此外，为了支持KVM-PT中的Ring 3跟踪，我们设置了模型特定寄存器IA32 RTIT CTL MSR中的User位。由于原始的KAFL是设计为内核模糊器，它只设置IA32 RTIT CTL MSR.OS以启用Ring 0跟踪。此外，原始模糊器只打算对64位操作系统进行模糊测试。然而，由于某些CGC二进制文件只能编译为32位目标，我们扩展了模糊器以支持32位目标。因此，我们在QEMU-PT中添加了32位模式解码，以支持对32位模式Intel PT跟踪数据的解码。