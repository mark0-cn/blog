### clone trait 与 copy trait 的区别 

```
copy():
+--------+       +--------+
| person1|       | person2|
+--------+       +--------+
|  name  |----|   name  |----------
+--------+    |   +--------+      |
|  age   |    |   |  age   |      |
+--------+    |   +--------+      |
              |                   |
              -----            |---
                  |            | 
堆空间：           |     --------
                  V    V
+--------+      +---------+  
|  name  |----> | "Alice" | 
+--------+      +---------+  

clone()方法复制：
+--------+       +--------+
| person1|       | person3|
+--------+       +--------+
|  name  |----   |   name  |------
+--------+    |  +--------+      |
|  age   |    |  |  age   |      |
+--------+    |  +--------+      |
              |                  |
              -----              |
                  |              | 
堆空间：           |              |     
                  V              V
+--------+      +---------+   +---------+  
|  name  |----> | "Alice" |   | "Alice" | 
+--------+      +---------+   +---------+  
                   旧空间         新空间
```

### 什么情况使用panic

+ 非预期的错误
+ 后续代码的运行会受到显著影响
+ 内存安全的问题

### panic 原理剖析

当调用 panic! 宏时，它会

1. 格式化 panic 信息，然后使用该信息作为参数，调用 std::panic::panic_any() 函数

2. panic_any 会检查应用是否使用了 panic hook，如果使用了，该 hook 函数就会被调用（hook 是一个钩子函数，是外部代码设置的，用于在 panic 触发时，执行外部代码所需的功能）

3. 当 hook 函数返回后，当前的线程就开始进行栈展开：从 panic_any 开始，如果寄存器或者栈因为某些原因信息错乱了，那很可能该展开会发生异常，最终线程会直接停止，展开也无法继续进行

4. 展开的过程是一帧一帧的去回溯整个栈，每个帧的数据都会随之被丢弃，但是在展开过程中，你可能会遇到被用户标记为 catching 的帧（通过 std::panic::catch_unwind() 函数标记），此时用户提供的 catch 函数会被调用，展开也随之停止：当然，如果 catch 选择在内部调用 std::panic::resume_unwind() 函数，则展开还会继续。

还有一种情况，在展开过程中，如果展开本身 panic 了，那展开线程会终止，展开也随之停止。

一旦线程展开被终止或者完成，最终的输出结果是取决于哪个线程 panic：对于 main 线程，操作系统提供的终止功能 core::intrinsics::abort() 会被调用，最终结束当前的 panic 进程；如果是其它子线程，那么子线程就会简单的终止，同时信息会在稍后通过 std::thread::join() 进行收集。

### Cargo.toml vs Cargo.lock

Cargo.toml 和 Cargo.lock 是 Cargo 的两个元配置文件，但是它们拥有不同的目的:

+ 前者从用户的角度出发来描述项目信息和依赖管理，因此它是由用户来编写
+ 后者包含了依赖的精确描述信息，它是由 Cargo 自行维护，因此不要去手动修改

它们的关系跟 package.json 和 package-lock.json 非常相似，从 JavaScript 过来的同学应该会比较好理解。

是否上传本地的 Cargo.lock？

当本地开发时，Cargo.lock 自然是非常重要的，但是当你要把项目上传到 Git 时，例如 GitHub，那是否上传 Cargo.lock 就成了一个问题。

关于是否上传，有如下经验准则:

+ 从实践角度出发，如果你构建的是三方库类型的服务，请把 Cargo.lock 加入到 .gitignore 中。
+ 若构建的是一个面向用户终端的产品，例如可以像命令行工具、应用程序一样执行，那就把 Cargo.lock 上传到源代码目录中。

例如 axum 是 web 开发框架，它属于三方库类型的服务，因此源码目录中不应该出现 Cargo.lock 的身影，它的归宿是 .gitignore。而 ripgrep 则恰恰相反，因为它是一个面向终端的产品，可以直接运行提供服务。

那么问题来了，为何会有这种选择？

原因是 Cargo.lock 会详尽描述上一次成功构建的各种信息：环境状态、依赖、版本等等，Cargo 可以使用它提供确定性的构建环境和流程，无论何时何地。这种特性对于终端服务是非常重要的：能确定、稳定的在用户环境中运行起来是终端服务最重要的特性之一。

而对于三方库来说，情况就有些不同。它不仅仅被库的开发者所使用，还会间接影响依赖链下游的使用者。用户引入了三方库是不会去看它的 Cargo.lock 信息的，也不应该受这个库的确定性运行条件所限制。